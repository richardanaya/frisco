<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Frisco Tour: Calculating Reason</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h1>The Frisco Tour</h1>
            <nav>
                <ul>
                    <li><a href="#welcome" class="nav-link active">1. The Vision</a></li>
                    
                    <li class="section-title">Metaphysics: What Is</li>
                    <li><a href="#reality" class="nav-link">2. Reality (I/O)</a></li>
                    <li><a href="#existence" class="nav-link">3. Existence (Entities)</a></li>
                    <li><a href="#identity" class="nav-link">4. Identity (Concepts)</a></li>
                    
                    <li class="section-title">Epistemology: How We Know</li>
                    <li><a href="#identification" class="nav-link">5. Identification (Queries)</a></li>
                    <li><a href="#semantics" class="nav-link">6. Measurement Omission</a></li>
                    <li><a href="#causality" class="nav-link">7. Causality (Rules)</a></li>
                    
                    <li class="section-title">Logic: The Art of Reasoning</li>
                    <li><a href="#evidence" class="nav-link">8. Evidence (Lists)</a></li>
                    <li><a href="#conflict" class="nav-link">9. Conflict (Negation)</a></li>
                    <li><a href="#argument" class="nav-link">10. Advanced: The Argument</a></li>
                    <li><a href="#synthesis" class="nav-link">11. Complex Synthesis</a></li>
                    
                    <li class="section-title">Reference</li>
                    <li><a href="#cheatsheet" class="nav-link">Cheatsheet</a></li>
                    <li><a href="#builtins" class="nav-link">Built-ins</a></li>
                    <li><a href="#repl" class="nav-link">The REPL</a></li>
                </ul>
            </nav>
        </aside>

        <main class="content">
            <!-- 1. The Vision -->
            <section id="welcome" class="lesson active">
                <h2>1. The Vision: Calculemus!</h2>
                <p>
                    <strong>"Let us calculate!"</strong> — Gottfried Wilhelm Leibniz
                </p>
                <p>
                    Welcome to Frisco. You are about to learn a language not just for processing data, but for 
                    <strong>processing ideas</strong>.
                </p>
                <p>
                    Most languages ask: <em>"How do I compute this number?"</em><br>
                    Frisco asks: <em>"Is this argument valid? Does this concept apply?"</em>
                </p>
                <h3>The Philosophy</h3>
                <p>
                    Frisco combines three powerful traditions:
                </p>
                <ul>
                    <li><strong>Logic Programming (Prolog):</strong> Reasoning through declarative rules and unification.</li>
                    <li><strong>Objectivist Epistemology (Rand):</strong> Concepts defined by essentials; similarity as measurement omission.</li>
                    <li><strong>Vector Semantics (AI):</strong> Using embeddings to bridge the gap between rigid symbols and fuzzy reality.</li>
                </ul>
                <p>
                    In this tour, we will build a <strong>computational ontology</strong> to resolve a philosophical debate. 
                    Step by step, we will move from raw existence to complex argumentation.
                </p>
            </section>

            <!-- 2. Reality -->
            <section id="reality" class="lesson">
                <h2>2. Reality: "A is A"</h2>
                <p>
                    In Frisco, we start with the axiom of identity. Things are what they are. 
                    Our first task is simply to acknowledge reality using Input/Output.
                </p>
                <pre><code class="language-frisco">println("Existence exists.").
print("A is ", "A").</code></pre>
                <h3>Atoms & Strings</h3>
                <p>
                    Data in Frisco comes in two primary forms:
                </p>
                <ul>
                    <li><strong>Strings:</strong> <code>"Text in quotes"</code>. Used for descriptions and semantic matching.</li>
                    <li><strong>Atoms:</strong> <code>lowercase_identifiers</code>. Used for symbolic tags and relations.</li>
                </ul>
            </section>

            <!-- 3. Existence -->
            <section id="existence" class="lesson">
                <h2>3. Existence: The Given</h2>
                <p>
                    Before we can reason, we must have something to reason <em>about</em>. 
                    <strong>Entities</strong> are the concrete existents in our universe.
                </p>
                <p>
                    Let's introduce our protagonist.
                </p>
                <pre><code class="language-frisco">entity SOCRATES: Man.
  description = "The gadfly of Athens"
  origin = "Athens"
  method = "Dialectic"</code></pre>
                <p>
                    Here, <code>SOCRATES</code> is the identifier (always Uppercase). 
                    <code>Man</code> is the concept he belongs to (we'll define that next).
                    The fields (<code>description</code>, <code>origin</code>) are his specific attributes.
                </p>
            </section>

            <!-- 4. Identity -->
            <section id="identity" class="lesson">
                <h2>4. Identity: Abstraction</h2>
                <p>
                    To think, we must integrate particulars into concepts. 
                    A <strong>Concept</strong> is defined by its <em>essentials</em> (what makes it what it is) 
                    and its <em>attributes</em> (observable properties).
                </p>
                <pre><code class="language-frisco">concept Man.
  description = "Rational animal"
  attributes = ["biological", "bipedal", "mammal"]
  essentials = ["rational_faculty", "volitional_consciousness"]</code></pre>
                <div class="note">
                    <strong>Objectivist Note:</strong> Notice we define <code>essentials</code>. 
                    This isn't just metadata; it's how we will later scientifically classify entities.
                    The <code>attributes</code> are the "measurements" we might observe.
                </div>
            </section>

            <!-- 5. Identification -->
            <section id="identification" class="lesson">
                <h2>5. Identification: Queries</h2>
                <p>
                    Logic is the art of non-contradictory identification. 
                    In Frisco, we identify facts using the <strong>Query Operator</strong> <code>?</code>.
                </p>
                <p>Accessing properties is direct:</p>
                <pre><code class="language-frisco">? SOCRATES.description.
# "The gadfly of Athens"</code></pre>
                <h3>Unification</h3>
                <p>
                    We can ask "What is X?" using variables (Capitalized). 
                    Frisco finds the value that makes the equation true.
                </p>
                <pre><code class="language-frisco">? X = SOCRATES.
# Bindings: X = SOCRATES</code></pre>
            </section>

            <!-- 6. Semantics -->
            <section id="semantics" class="lesson">
                <h2>6. Measurement Omission</h2>
                <p>
                    <strong>"A concept is a mental integration of two or more units... with their particular measurements omitted."</strong> — Ayn Rand
                </p>
                <p>
                    Traditional logic is brittle. To a standard computer, <code>"dog"</code> and <code>"canine"</code> are as different as <code>"dog"</code> and <code>"math"</code> because their characters don't match. The machine gets stuck on the specific "measurements" (spelling, sound) and misses the identity.
                </p>
                <p>
                    Frisco solves this by treating <strong>meaning as a vector space</strong>. 
                    Using embeddings, we map words to concepts. The distance between vectors represents the "measurements" we omit.
                </p>

                <h3>The Semantic Operator: <code>=~=</code></h3>
                <p>
                    This operator asks: <em>"Do these terms refer to the same concept?"</em> (Is the vector distance within a tolerance threshold?)
                </p>
                <pre><code class="language-frisco"># Synonyms match (Measurement omitted: exact word choice)
? "furious" =~= "angry".
# True

# Descriptions match (Measurement omitted: phrasing)
? "The gadfly of Athens" =~= "ancient Greek philosopher".
# True

# Lists match if ANY element fits (Integration of units)
? ["crimson", "scarlet", "ruby"] =~= "red".
# True</code></pre>

                <h3>Dimensional Similarity</h3>
                <p>
                    Similarity is context-dependent. "Ruby" and "Blood" are similar in color, but radically different in material. 
                    To be scientifically precise, we must specify the <strong>Dimension</strong> of comparison.
                </p>
                <p>
                    Use <code>similar_attr(Dimension, A, B)</code> to scope the measurement omission:
                </p>
                <pre><code class="language-frisco"># Are they similar in material?
? similar_attr(material, "Ruby", "Blood").
# False (Mineral vs Biological Fluid)

# Are they similar in color?
? similar_attr(color, "Ruby", "Blood").
# True (Both are Deep Red)</code></pre>

                <h4>How It Works: Contextual Framing</h4>
                <p>
                    You might wonder: <em>How does the machine know what 'color' is?</em>
                </p>
                <p>
                    In the query <code>similar_attr(color, "Ruby", "Blood")</code>, <code>color</code> is an <strong>Atom</strong> (unquoted identifier). We use Atoms as precise code tags, but Frisco uses their <em>names</em> to build the semantic prompt.
                </p>
                <ul>
                    <li>Frisco takes the atom <code>color</code> and the string <code>"Ruby"</code>.</li>
                    <li>It constructs a natural language phrase: <strong>"color of Ruby"</strong>.</li>
                    <li>It compares the vector for that phrase against <strong>"color of Blood"</strong>.</li>
                </ul>
                <p>
                    This is why we use atoms like <code>color</code>, <code>material</code>, or <code>shape</code>—they serve double duty as rigid code symbols AND meaningful semantic guides.
                </p>
                
                <p>
                    <strong>The Power:</strong> This allows you to write rules that focus on <em>essentials</em> (like material properties) while robustly ignoring accidental differences (like poetic descriptions), or vice versa.
                </p>
            </section>

            <!-- 7. Causality -->
            <section id="causality" class="lesson">
                <h2>7. Causality: Rules</h2>
                <p>
                    A <strong>Rule</strong> identifies a causal or logical relationship. 
                    It follows the form: <em>Conclusion is true IF Premises are true.</em>
                </p>
                <pre><code class="language-frisco"># Format: Head :- Body.
mortal(X) :- 
    X.description =~= "human",      # Premise 1
    Man.attributes =~= "dies".      # Premise 2</code></pre>
                <p>
                    This is a syllogism in code. 
                    To prove <code>mortal(X)</code>, Frisco must prove X is human AND Man is mortal.
                </p>
                <pre><code class="language-frisco">? mortal(SOCRATES).
# True</code></pre>
            </section>

            <!-- 8. Evidence -->
            <section id="evidence" class="lesson">
                <h2>8. Evidence: Collecting Facts</h2>
                <p>
                    An argument often requires gathering all available evidence. 
                    We use <code>findall</code> to collect solutions into a List.
                </p>
                <pre><code class="language-frisco">entity PLATO: Man. description = "Student of Socrates".
entity ARISTOTLE: Man. description = "The Philosopher".

# Gather all philosophers
? findall(P, P.description =~= "philosopher", Philosophers).
# Philosophers = [SOCRATES, PLATO, ARISTOTLE]</code></pre>
                <p>
                    Lists allow us to reason about groups, majorities, or chains of evidence.
                </p>
            </section>

            <!-- 9. Conflict -->
            <section id="conflict" class="lesson">
                <h2>9. Conflict: Negation & Cut</h2>
                <p>
                    Reasoning involves contradictions. Sometimes a rule applies <em>unless</em> a specific exception exists. 
                    Frisco handles this with two powerful tools: <strong>Negation</strong> and the <strong>Cut</strong>.
                </p>

                <h3>Negation as Failure</h3>
                <p>
                    In Frisco, <code>not(X)</code> is true if X <strong>cannot be proven</strong>.
                </p>
                <pre><code class="language-frisco"># If we cannot find evidence that X is guilty, we assume innocent.
innocent(X) :- not(guilty(X)).</code></pre>
                <div class="note">
                    <strong>Warning:</strong> This is "closed-world assumption." If the database doesn't know X is guilty, Frisco assumes X is innocent.
                </div>

                <h3>The Cut (`!`)</h3>
                <p>
                    Normally, if a rule fails, Frisco <strong>backtracks</strong> to try other rules. 
                    The <strong>Cut</strong> (<code>!</code>) stops this. It says: <em>"If you got this far, commit to this path. Do not look for alternatives."</em>
                </p>

                <h3>Pattern: If-Then-Else</h3>
                <p>
                    We use Cut to create exceptions. Consider the definition of <strong>Immortality</strong>:
                </p>

                <pre><code class="language-frisco"># Rule 1: Gods are immortal (The Exception)
immortal(X) :- 
    god(X), 
    !.        # &lt;-- THE GATE. If X is a god, stop here. Success!

# Rule 2: Everyone else is immortal only if NOT mortal
immortal(X) :- 
    not(mortal(X)).</code></pre>

                <h4>Trace the Logic:</h4>
                <ol>
                    <li><strong>Query:</strong> <code>? immortal(ZEUS).</code> (Assume <code>god(ZEUS)</code> is true)
                        <ul>
                            <li>Frisco tries Rule 1.</li>
                            <li><code>god(ZEUS)</code> matches.</li>
                            <li>It hits the <strong>Cut (!)</strong>. The decision is final.</li>
                            <li>Result: <strong>True</strong>. (Rule 2 is never touched).</li>
                        </ul>
                    </li>
                    <li><strong>Query:</strong> <code>? immortal(SOCRATES).</code> (Assume Socrates is not a god)
                        <ul>
                            <li>Frisco tries Rule 1.</li>
                            <li><code>god(SOCRATES)</code> fails.</li>
                            <li>Since it failed <em>before</em> the Cut, Frisco <strong>backtracks</strong>.</li>
                            <li>Frisco tries Rule 2.</li>
                            <li>Is <code>not(mortal(SOCRATES))</code> true? No, he is mortal.</li>
                            <li>Result: <strong>False</strong>.</li>
                        </ul>
                    </li>
                </ol>
            </section>

            <!-- 10. The Argument -->
            <section id="argument" class="lesson">
                <h2>10. Advanced: The Argument: Justice</h2>
                <p>
                    Let's put it all together. We will determine if a specific action is <strong>Just</strong>.
                </p>
                <pre><code class="language-frisco">concept Justice.
  essentials = ["respect_for_rights", "objective_law"]

concept Action.
  attributes = ["voluntary", "coercive"]

entity TAXATION: Action.
  description = "State seizure of income"

# The Definition of Justice
is_just(Act) :-
    Act.description =~= "voluntary exchange",
    !.
    
is_just(Act) :-
    Act.description =~= "defense of rights",
    !.

is_just(Act) :-
    Act.description =~= "coercive",
    println("Injustice detected: ", Act),
    fail.  # Force failure

# The Verdict
? is_just(TAXATION).</code></pre>
                <p>
                    This is the power of Frisco. We define our terms, establish our principles, 
                    and let the system <strong>calculate the verdict</strong>.
                </p>

                <h4>How It Works: The Logic of Exclusion</h4>
                <p>
                    This argument works by systematically eliminating possibilities using the Cut (<code>!</code>).
                </p>
                <ul>
                    <li><strong>Rule 1 (Voluntary):</strong> Is it a voluntary exchange? If yes, <strong>Stop</strong> (Cut). It is Just.</li>
                    <li><strong>Rule 2 (Defense):</strong> Is it a defense of rights? If yes, <strong>Stop</strong> (Cut). It is Just.</li>
                    <li><strong>Rule 3 (Coercion):</strong> If we reached here, it wasn't voluntary or defensive. Is it Coercive? If yes, <strong>FAIL</strong>. It is NOT Just.</li>
                </ul>
                <p>
                    Frisco acts as an automated judge, walking down the decision tree you built.
                </p>
            </section>

            <!-- 11. Complex Synthesis -->
            <section id="synthesis" class="lesson">
                <h2>11. Complex Synthesis: The Eminent Domain Case</h2>
                <p>
                    A classic conflict in political philosophy is "Public Interest" vs. "Private Rights." 
                    Governments often use the "greater good" to justify actions that would otherwise be crimes.
                </p>

                <h3>The Scenario</h3>
                <p>
                    Consider the case of <strong>Eminent Domain</strong> (e.g., the Kelo decision).
                </p>
                <pre><code class="language-frisco">entity STADIUM_PROJECT: Action.
  description = "Evicting families from their private homes to build a sports stadium that boosts city tax revenue."</code></pre>

                <h3>The Analysis</h3>
                <p>
                    We dissect the event to separate the <strong>Physical Act</strong> from the <strong>Social Justification</strong>.
                </p>

                <pre><code class="language-frisco"># Dimension 1: The METHOD (Reality)
# Focuses on "Evicting families from their private homes"
is_violation(Act) :-
    similar_attr(method, Act.description, "violation of property rights").

# Dimension 2: The JUSTIFICATION (Utilitarian)
# Focuses on "boosts city tax revenue"
is_utilitarian(Act) :-
    similar_attr(intent, Act.description, "public benefit at the expense of the individual").

# The Synthesis Rule
analyze_rights_violation(Act) :-
    println("Analyzing: ", Act),
    
    # Check dimensions
    (is_violation(Act) -> println("  - Method: Rights Violation") ; println("  - Method: Respects Rights")),
    (is_utilitarian(Act) -> println("  - Justification: Collectivist (The Greater Good)") ; println("  - Justification: Individualist")),
    
    # Synthesize
    is_violation(Act),
    is_utilitarian(Act),
    println("  => VERDICT: Injustice. (Individual rights are absolute and cannot be traded for public gain).").</code></pre>

                <h3>The Execution</h3>
                <pre><code class="language-frisco">? analyze_rights_violation(STADIUM_PROJECT).
# Output:
# Analyzing: STADIUM_PROJECT
#   - Method: Rights Violation
#   - Justification: Collectivist (The Greater Good)
#   => VERDICT: Injustice. (Individual rights are absolute and cannot be traded for public gain).
# True</code></pre>
                
                <h4>How It Works: Reality vs. Rhetoric</h4>
                <p>
                    Frisco cuts through the political spin:
                </p>
                <ol>
                    <li>
                        <strong>Method Extraction:</strong> The AI ignores the "stadium" and "revenue." It sees "Evicting families" and matches it to <strong>Rights Violation</strong>.
                    </li>
                    <li>
                        <strong>Justification Extraction:</strong> The AI ignores the eviction. It sees "boosts city revenue" and matches it to <strong>Collectivist/Utilitarian</strong> logic.
                    </li>
                </ol>
                <p>
                    By isolating these dimensions, Frisco refuses to accept the premise that "more tax revenue" can mathematically cancel out "forced eviction."
                </p>
            </section>

            <!-- Reference Sections -->
            <section id="cheatsheet" class="lesson">
                <h2>Cheatsheet</h2>
                <ul>
                    <li><code>Concept Name.</code> - Define abstract</li>
                    <li><code>Entity NAME: Type.</code> - Define concrete</li>
                    <li><code>Head :- Body.</code> - Define rule</li>
                    <li><code>? Query.</code> - Ask question</li>
                    <li><code>=~=</code> - Semantic match</li>
                    <li><code>=</code> - Unification</li>
                    <li><code>_</code> - Anonymous variable</li>
                </ul>
            </section>

            <section id="builtins" class="lesson">
                <h2>Built-ins</h2>
                <p>See documentation for full list.</p>
                <ul>
                    <li><code>println/print</code> - Output</li>
                    <li><code>readln</code> - Input</li>
                    <li><code>findall/setof</code> - Collection</li>
                    <li><code>member/append</code> - List operations</li>
                    <li><code>is_atom/is_list</code> - Type checks</li>
                    <li><code>similar_attr</code> - Dimensional match</li>
                </ul>
            </section>

            <section id="repl" class="lesson">
                <h2>The REPL</h2>
                <p>Run <code>npm run repl</code> to enter the interactive reasoner.</p>
                <pre><code class="language-bash">:help      # Show commands
:kb        # Show current knowledge base
:quit      # Exit</code></pre>
            </section>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="js/frisco-prism.js"></script>
    <script src="js/tour.js"></script>
</body>
</html>