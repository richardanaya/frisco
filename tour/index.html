<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Tour of Frisco</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h1>A Tour of Frisco</h1>
            <nav>
                <ul>
                    <li><a href="#welcome" class="nav-link active">Welcome</a></li>
                    <li class="section-title">Basics</li>
                    <li><a href="#hello" class="nav-link">Hello, World</a></li>
                    <li><a href="#concepts" class="nav-link">Concepts</a></li>
                    <li><a href="#entities" class="nav-link">Entities</a></li>
                    <li><a href="#queries" class="nav-link">Queries</a></li>
                    <li class="section-title">Logic & Rules</li>
                    <li><a href="#predicates" class="nav-link">Predicates</a></li>
                    <li><a href="#rules" class="nav-link">Rules</a></li>
                    <li><a href="#variables" class="nav-link">Variables</a></li>
                    <li><a href="#unification" class="nav-link">Unification & Equality</a></li>
                    <li><a href="#operators" class="nav-link">Equality & Comparison Cheatsheet</a></li>
                    <li><a href="#operators-why" class="nav-link">Why So Many Operators?</a></li>
                    <li><a href="#types" class="nav-link">Terms & Types</a></li>
                    <li><a href="#control" class="nav-link">Negation, Cut, Control</a></li>
                    <li><a href="#lists" class="nav-link">Lists & Pattern Matching</a></li>
                    <li><a href="#semantic-comparison" class="nav-link">Semantic Comparison</a></li>
                    <li><a href="#argument" class="nav-link">Argument Walkthrough</a></li>
                    <li><a href="#solutions" class="nav-link">Multiple Solutions</a></li>
                    <li class="section-title">Advanced</li>
                    <li><a href="#builtins" class="nav-link">Built-ins Reference</a></li>
                    <li><a href="#semantic" class="nav-link">Semantic Matching</a></li>
                    <li><a href="#interactive" class="nav-link">Interactive Programs</a></li>
                    <li><a href="#repl" class="nav-link">Using the REPL</a></li>
                </ul>
            </nav>
        </aside>

        <main class="content">
            <!-- Welcome -->
            <section id="welcome" class="lesson active">
                <h2>Welcome to Frisco</h2>
                <p>
                    Frisco is a logic programming language inspired by Prolog, focused on argument and ontology analysis.
                    It keeps the earliest Prolog essentials (unification, backtracking, Horn clauses, cut/negation) and
                    adds semantic similarity to model measurement omission in Objectivist terms.
                </p>
                <p>
                    This tour walks step by step from concepts and entities to semantic comparison and a full argument
                    walkthrough, showing how to build and query a small ontology.
                </p>
                <h3>What You'll Learn</h3>
                <ul>
                    <li>How to define concepts and entities (genus/differentia, essentials)</li>
                    <li>Writing queries, predicates, and rules with unification/backtracking</li>
                    <li>Controlling search with cut, negation, disjunction, if-then-else</li>
                    <li>Applying semantic comparison (`=~=` and `similar_attr/3`) as measurement omission</li>
                    <li>Collecting evidence with findall/setof and assembling arguments</li>
                </ul>
            </section>

            <!-- Hello World -->
            <section id="hello" class="lesson">
                <h2>Hello, World</h2>
                <p>
                    Let's start with the classic "Hello, World!" program. In Frisco, we use
                    the <code>println</code> predicate to print output.
                </p>
                <pre><code class="language-frisco">println("Hello, World!")</code></pre>
                <p>
                    Frisco doesn't require periods at the end of statements.
                </p>
                <p>
                    You can also use <code>print</code> for output without a newline:
                </p>
                <pre><code class="language-frisco">print("Hello, ")
println("World!")</code></pre>
            </section>

            <!-- Concepts -->
            <section id="concepts" class="lesson">
                <h2>Concepts</h2>
                <p>
                    Concepts represent categories in your ontology.
                </p>
                <pre><code class="language-frisco">concept Person
  description = "rational animal"
  attributes = ["occupation", "origin"]
  essentials = [rational, mortal]</code></pre>
                <h3>Concept Hierarchies</h3>
                <pre><code class="language-frisco">concept Philosopher: Person
  description = "lover of wisdom"</code></pre>
            </section>

            <!-- Entities -->
            <section id="entities" class="lesson">
                <h2>Entities</h2>
                <p>Entities are instances of concepts.</p>
                <pre><code class="language-frisco">entity SOCRATES: Philosopher
  description = "ancient Greek philosopher"
  origin = "Athens"
  occupation = "teacher"</code></pre>
            </section>

            <!-- Queries -->
            <section id="queries" class="lesson">
                <h2>Queries</h2>
                <p>Use <code>?</code> to ask about the knowledge base.</p>
                <pre><code class="language-frisco">? Philosopher.attributes
? SOCRATES.description</code></pre>
            </section>

            <!-- Predicates -->
            <section id="predicates" class="lesson">
                <h2>Predicates</h2>
                <p>Predicates describe relationships or properties.</p>
                <pre><code class="language-frisco">teacher(X) :- X.occupation =~= "teacher".</code></pre>
            </section>

            <!-- Rules -->
            <section id="rules" class="lesson">
                <h2>Rules</h2>
                <p>Create Horn clauses to derive new facts.</p>
                <pre><code class="language-frisco">wise(X) :- Philosopher(X), X.description =~= "philosopher".</code></pre>
            </section>

            <!-- Variables -->
            <section id="variables" class="lesson">
                <h2>Variables</h2>
                <p>Variables start with uppercase; <code>_</code> is anonymous.</p>
                <pre><code class="language-frisco">? wise(X).</code></pre>
            </section>

            <!-- Unification & Equality -->
            <section id="unification" class="lesson">
                <h2>Unification & Equality</h2>
                <pre><code class="language-frisco">? X = SOCRATES.
Bindings:
  X = SOCRATES
True

? SOCRATES == SOCRATES.
True</code></pre>
            </section>

            <!-- Operators Cheatsheet -->
            <section id="operators" class="lesson">
                <h2>Equality & Comparison Cheatsheet</h2>
                <ul>
                    <li><code>=</code>: Unification (binds variables, structural)</li>
                    <li><code>==</code>: Structural equality test (no binding)</li>
                    <li><code>=~=</code>: Semantic match using embeddings (strings/lists)</li>
                    <li><code>similar_attr(Dim, A, B)</code>: Semantic comparison scoped to a dimension</li>
                </ul>
                <pre><code class="language-frisco">? X = [a,b].
Bindings:
  X = [a, b]
True

? [red, blue] == [red, blue].
True

? "canine" =~= "dog".
True

? similar_attr(color, "deep crimson", "dark red").
True</code></pre>
            </section>

            <!-- Why Operators -->
            <section id="operators-why" class="lesson">
                <h2>Why So Many Operators?</h2>
                <p>Frisco separates structural unification from semantic similarity.</p>
                <ul>
                    <li><strong>Unification</strong> (<code>=</code>) binds terms and drives backtracking.</li>
                    <li><strong>Structural test</strong> (<code>==</code>) checks shapes without binding.</li>
                    <li><strong>Semantic match</strong> (<code>=~=</code>) is fuzzy; <strong>Dimensional semantic</strong> (<code>similar_attr/3</code>) scopes fuzziness by attribute.</li>
                </ul>
                <p>This keeps search declarative and backtracking-safe.</p>
            </section>

            <!-- Terms & Types -->
            <section id="types" class="lesson">
                <h2>Terms & Types</h2>
                <ul>
                    <li><strong>Atoms</strong>: lowercase identifiers or quoted strings.</li>
                    <li><strong>Variables</strong>: bind during unification; <code>_</code> is anonymous.</li>
                    <li><strong>Lists</strong>: <code>[a,b,c]</code>, head/tail <code>[H|T]</code>.</li>
                    <li><strong>Compound terms</strong>: <code>likes(socrates, philosophy)</code>.</li>
                    <li><strong>Field access</strong>: <code>Entity.field</code> for KB lookups.</li>
                </ul>
                <p>Guards: <code>is_atom/1</code>, <code>is_list/1</code>, <code>is_bound/1</code>, <code>is_unbound/1</code>.</p>
            </section>

            <!-- Control -->
            <section id="control" class="lesson">
                <h2>Negation, Cut, and Control</h2>
                <p>Control operators steer backtracking.</p>
                <ul>
                    <li><code>not(Goal)</code> or <code>\+ Goal</code>: negation as failure.</li>
                    <li><code>Goal1 ; Goal2</code>: disjunction.</li>
                    <li><code>Cond -> Then ; Else</code>: if-then-else.</li>
                    <li><code>!</code>: cut; prunes choice points.</li>
                </ul>
                <pre><code class="language-frisco">mortal(X) :- person(X), !, not(immortal(X)).
maybe_philosopher(X) :- scholar(X) ; writer(X).
</code></pre>
            </section>

            <!-- Lists -->
            <section id="lists" class="lesson">
                <h2>Lists & Pattern Matching</h2>
                <p>Lists are first-class with head/tail pattern matching.</p>
                <pre><code class="language-frisco">[a, b, c]
[H|T] = [a, b, c].  % H = a, T = [b, c]

append([], L, L).
append([H|T1], L2, [H|T3]) :- append(T1, L2, T3).

? append([red], [blue], R).
Bindings:
  R = [red, blue]
True</code></pre>
                <p>Built-ins include <code>member/2</code>, <code>append/3</code>, <code>reverse/2</code>, and <code>is_list/1</code>.</p>
            </section>

            <!-- Semantic Comparison -->
            <section id="semantic-comparison" class="lesson">
                <h2>Semantic Comparison</h2>
                <p>Use <code>=~=</code> and <code>similar_attr/3</code> to approximate measurement omission.</p>
                <pre><code class="language-frisco">? "canine" =~= "dog".
True

? similar_attr(color, "deep crimson", "dark red").
True</code></pre>
            </section>

            <!-- Argument Walkthrough -->
            <section id="argument" class="lesson">
                <h2>Argument Walkthrough</h2>
                <p>A tiny ontology and claim, showing semantic matching and evidence collection.</p>
                <pre><code class="language-frisco">concept Person.
concept Philosopher: Person.
  attributes = ["mortal"]

entity SOCRATES: Philosopher.
  description = "ancient Greek philosopher"
  origin = "Athens"

mortal(X) :- X.description =~= "philosopher", Philosopher.attributes =~= "mortal".

? mortal(SOCRATES).
True

% Collect all supporters
? findall(X, mortal(X), People).
Bindings:
  People = [SOCRATES]</code></pre>
                <p>Extend by adding more entities and attributes; use <code>similar_attr/3</code> to compare descriptors within dimensions.</p>
            </section>

            <!-- Multiple Solutions -->
            <section id="solutions" class="lesson">
                <h2>Multiple Solutions & Collection</h2>
                <p>Backtracking explores all solutions; use findall/setof to gather them.</p>
                <pre><code class="language-frisco">concept Person.
entity SOCRATES: Person.
entity PLATO: Person.
entity ARISTOTLE: Person.

? X.concept == Person.
Bindings:
  X = SOCRATES
  X = PLATO
  X = ARISTOTLE
True

? findall(X, X.concept == Person, People).
Bindings:
  People = [SOCRATES, PLATO, ARISTOTLE]
True</code></pre>
            </section>

            <!-- Built-ins -->
            <section id="builtins" class="lesson">
                <h2>Built-ins Reference</h2>
                <p>Each built-in with its behavior and a quick example. Frisco is optimized for argument and ontology analysis, not numeric computation.</p>
                <h3>I/O</h3>
                <ul>
                    <li><code>println(X, ...)</code> — render arguments and print with newline.</li>
                    <li><code>print(X, ...)</code> — render arguments without newline.</li>
                    <li><code>readln(Var)</code> — read one line from stdin into <code>Var</code> (string).</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? print("Hello"), print(" "), println("world").
Hello world
True

? readln(Name), println(Name).
Alice
Alice
True</code></pre>
                </details>

                <h3>Lists</h3>
                <ul>
                    <li><code>member(Element, List)</code> — succeeds or generates elements.</li>
                    <li><code>append(A, B, Result)</code> — concatenate or split.</li>
                    <li><code>reverse(List, Reversed)</code> — reverse a list.</li>
                    <li><code>is_list(X)</code> — succeeds for lists.</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? member(X, [a, b, c]).
Bindings:
  X = a
  X = b
  X = c
True

? append([1,2], [3,4], R).
Bindings:
  R = [1, 2, 3, 4]
True

? reverse([red, blue], R).
Bindings:
  R = [blue, red]
True</code></pre>
                </details>

                <h3>Semantic comparison</h3>
                <ul>
                    <li><code>=~=</code> — semantic match (fuzzy string/list comparison via embeddings).</li>
                    <li><code>similar_attr(Dim, A, B)</code> — succeeds if descriptors <code>A</code> and <code>B</code> are semantically close for a dimension.</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? "canine" =~= "dog".
True

? similar_attr(color, "deep crimson", "dark red").
True</code></pre>
                </details>

                <h3>Type predicates</h3>
                <ul>
                    <li><code>is_unbound(X)</code> — succeeds if <code>X</code> is an unbound variable.</li>
                    <li><code>is_bound(X)</code> — succeeds if <code>X</code> is not a free variable.</li>
                    <li><code>is_atom(X)</code> — succeeds for atoms or string literals.</li>
                    <li><code>is_list(X)</code> — succeeds for lists.</li>
                    <li>Anonymous <code>_</code> is always fresh and unbound.</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? is_unbound(X).
True

? X = foo, is_bound(X).
Bindings:
  X = foo
True

? is_atom("dog").
True

? is_list([a,b]).
True</code></pre>
                </details>

                <h3>Solutions</h3>
                <ul>
                    <li><code>findall(Template, Goal, List)</code> — collect all solutions of <code>Goal</code> for <code>Template</code> into <code>List</code> (returns <code>[]</code> if none).</li>
                    <li><code>setof(Template, Goal, List)</code> — collect like <code>findall</code> but remove duplicates (first-seen order here).</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">likes(socrates, olives).
likes(plato, olives).
likes(plato, olives).  % duplicate

% All solutions (duplicates kept)
? findall(X, likes(X, olives), L).
Bindings:
  L = [socrates, plato, plato]
True

% Deduplicated collection
? setof(X, likes(X, olives), L).
Bindings:
  L = [socrates, plato]
True</code></pre>
                </details>
            </section>

            <!-- Semantic Matching -->
            <section id="semantic" class="lesson">
                <h2>Semantic Matching</h2>
                <p>One of Frisco's unique features is semantic matching using the <code>=~=</code> operator.</p>
                <pre><code class="language-frisco">? SOCRATES.description =~= "thinker"</code></pre>
                <p>Uses embedding models to determine if phrases are semantically similar.</p>
            </section>

            <!-- Interactive Programs -->
            <section id="interactive" class="lesson">
                <h2>Interactive Programs</h2>
                <p>Frisco supports interactive programs using <code>readln</code> for user input.</p>
                <pre><code class="language-frisco">greet_user :-
  println("What is your name?"),
  readln(Name),
  print("Hello, "),
  print(Name),
  println("!"),
  println("Nice to meet you!")

? greet_user</code></pre>
            </section>

            <!-- Using the REPL -->
            <section id="repl" class="lesson">
                <h2>Using the REPL</h2>
                <p>Frisco includes a REPL for interactive development.</p>
                <h3>Starting the REPL</h3>
                <pre><code class="language-bash">npm run repl</code></pre>
                <h3>REPL Commands</h3>
                <ul>
                    <li><code>:help</code> - Show help message</li>
                    <li><code>:kb</code> - Display current knowledge base</li>
                    <li><code>:kb_save</code> - Save knowledge base to .frisco file</li>
                    <li><code>:kb_load</code> - Load knowledge base from file</li>
                    <li><code>:clear</code> - Clear screen</li>
                    <li><code>:quit</code> - Exit REPL</li>
                </ul>
            </section>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="js/frisco-prism.js"></script>
    <script src="js/tour.js"></script>
</body>
</html>
