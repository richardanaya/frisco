<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Tour of Frisco</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h1>A Tour of Frisco</h1>
            <nav>
                <ul>
                    <li><a href="#welcome" class="nav-link active">Welcome</a></li>
                    <li class="section-title">Basics</li>
                    <li><a href="#hello" class="nav-link">Hello, World</a></li>
                    <li><a href="#concepts" class="nav-link">Concepts</a></li>
                    <li><a href="#entities" class="nav-link">Entities</a></li>
                    <li><a href="#queries" class="nav-link">Queries</a></li>
                    <li class="section-title">Logic & Rules</li>
                    <li><a href="#predicates" class="nav-link">Predicates</a></li>
                    <li><a href="#rules" class="nav-link">Rules</a></li>
                    <li><a href="#variables" class="nav-link">Variables</a></li>
                    <li><a href="#unification" class="nav-link">Unification & Equality</a></li>
                    <li><a href="#operators" class="nav-link">Equality & Comparison Cheatsheet</a></li>
                    <li><a href="#operators-why" class="nav-link">Why So Many Operators?</a></li>
                    <li><a href="#types" class="nav-link">Terms & Types</a></li>
                    <li><a href="#control" class="nav-link">Negation, Cut, Control</a></li>
                    <li><a href="#lists" class="nav-link">Lists & Pattern Matching</a></li>
                    <li><a href="#arithmetic" class="nav-link">Arithmetic & Comparisons</a></li>
                    <li><a href="#solutions" class="nav-link">Multiple Solutions</a></li>
                    <li class="section-title">Advanced</li>
                    <li><a href="#builtins" class="nav-link">Built-ins Reference</a></li>
                    <li><a href="#semantic" class="nav-link">Semantic Matching</a></li>
                    <li><a href="#interactive" class="nav-link">Interactive Programs</a></li>
                    <li><a href="#repl" class="nav-link">Using the REPL</a></li>
                </ul>
            </nav>
        </aside>

        <main class="content">
            <!-- Welcome -->
            <section id="welcome" class="lesson active">
                <h2>Welcome to Frisco</h2>
                <p>
                    Frisco is a logic programming language inspired by Prolog, built on
                    Objectivist epistemology and enhanced with semantic matching capabilities.
                </p>
                <p>
                    This tour will guide you through the fundamentals of Frisco, from basic
                    concepts to advanced semantic reasoning.
                </p>
                <h3>What You'll Learn</h3>
                <ul>
                    <li>How to define concepts and entities</li>
                    <li>Writing queries and predicates</li>
                    <li>Creating logical rules</li>
                    <li>Using semantic matching for fuzzy reasoning</li>
                    <li>Building interactive programs</li>
                </ul>
                <p>
                    Click "Hello, World" in the sidebar to begin!
                </p>
            </section>

            <!-- Hello World -->
            <section id="hello" class="lesson">
                <h2>Hello, World</h2>
                <p>
                    Let's start with the classic "Hello, World!" program. In Frisco, we use
                    the <code>println</code> predicate to print output.
                </p>
                <pre><code class="language-frisco">println("Hello, World!")</code></pre>
                <p>
                    Notice that Frisco doesn't require periods at the end of statements. The
                    newline is sufficient!
                </p>
                <p>
                    You can also use <code>print</code> for output without a newline:
                </p>
                <pre><code class="language-frisco">print("Hello, ")
 println("World!")</code></pre>
                <p>
                    Use <code>println</code> to end with a newline, or <code>print</code> to continue on the same line.
                </p>

            </section>

            <!-- Concepts -->
            <section id="concepts" class="lesson">
                <h2>Concepts</h2>
                <p>
                    In Frisco, concepts are the fundamental units of knowledge. They represent
                    categories or types of things in your domain.
                </p>
                <pre><code class="language-frisco">concept Man
  description = "rational animal"</code></pre>
                <p>
                    Concepts can have optional attributes and essentials:
                </p>
                <pre><code class="language-frisco">concept Person
  description = "human being"
  attributes = [
    "name",
    "age",
    "occupation"
  ]
  essentials = [rational, mortal]</code></pre>
                <p>
                    The <code>description</code> provides semantic meaning, while
                    <code>attributes</code> and <code>essentials</code> define the
                    structure and necessary characteristics.
                </p>
                <h3>Concept Hierarchies</h3>
                <p>
                    Concepts can inherit from parent concepts using the <code>genus</code>
                    (parent concept) syntax:
                </p>
                <pre><code class="language-frisco">concept Animal
  description = "living organism"

concept Mammal: Animal
  description = "warm-blooded vertebrate"

concept Man: Mammal
  description = "rational animal"</code></pre>
                <p>
                    Access the parent concept using the <code>.genus</code> property:
                </p>
                <pre><code class="language-frisco">? println(Man.genus).    # Outputs: Mammal
? println(Mammal.genus). # Outputs: Animal</code></pre>
            </section>

            <!-- Entities -->
            <section id="entities" class="lesson">
                <h2>Entities</h2>
                <p>
                    Entities are specific instances of concepts. They represent concrete
                    things in your knowledge base.
                </p>
                <pre><code class="language-frisco">entity SOCRATES: Man
  description = "philosopher"</code></pre>
                <p>
                    Once defined, you can reference entities in queries and predicates:
                </p>
                <pre><code class="language-frisco">println(SOCRATES)</code></pre>
                <p>
                    Entity names are typically written in UPPERCASE to distinguish them
                    from variables and concepts.
                </p>
                <h3>Accessing Entity Properties</h3>
                <p>
                    You can access an entity's concept using the <code>.concept</code> property:
                </p>
                <pre><code class="language-frisco">entity SOCRATES: Man
  description = "philosopher"

? println(SOCRATES.concept). # Outputs: Man</code></pre>
                <p>
                    This is useful for reasoning about the types of entities in your knowledge base.
                </p>
                <pre><code class="language-frisco">concept City
  description = "large human settlement"

entity ATHENS: City
  description = "capital of Greece"

entity ROME: City
  description = "eternal city"</code></pre>
            </section>

            <!-- Queries -->
            <section id="queries" class="lesson">
                <h2>Queries</h2>
                <p>
                    Queries in Frisco begin with a question mark <code>?</code> and allow
                    you to execute predicates or test conditions.
                </p>
                <pre><code class="language-frisco">? println("Testing queries")</code></pre>
                <p>
                    In the REPL, the <code>?</code> is automatically added if you don't
                    include it, so you can simply type:
                </p>
                <pre><code class="language-frisco">println("This works too!")</code></pre>
                <p>
                    Queries can also test semantic matches and rules:
                </p>
                <pre><code class="language-frisco">? SOCRATES.description =~= "thinker"</code></pre>
                <p>
                    The <code>=~=</code> operator performs semantic matching, which we'll
                    explore in detail later.
                </p>
            </section>

            <!-- Predicates -->
            <section id="predicates" class="lesson">
                <h2>Predicates</h2>
                <p>
                    Predicates are the building blocks of logic in Frisco. Built-in predicates
                    include:
                </p>
                <ul>
                    <li><code>println(X)</code> - Print with newline</li>
                    <li><code>print(X)</code> - Print without newline</li>
                    <li><code>readln(X)</code> - Read user input into variable X</li>
                </ul>
                <h3>Using Predicates</h3>
                <pre><code class="language-frisco">println("What is your name?")
readln(Name)
print("Hello, ")
print(Name)
println("")</code></pre>
                <p>
                    Variables in Frisco start with uppercase letters, following Prolog
                    conventions.
                </p>
            </section>

            <!-- Rules -->
            <section id="rules" class="lesson">
                <h2>Rules</h2>
                <p>
                    Rules define logical relationships and allow you to create new knowledge
                    from existing facts.
                </p>
                <pre><code class="language-frisco">mortal(X) :-
  X.type =~= "Man"</code></pre>
                <p>
                    This rule states: "X is mortal if X's type semantically matches 'Man'".
                </p>
                <p>
                    Rules can have multiple conditions:
                </p>
                <pre><code class="language-frisco">philosopher(X) :-
  X.description =~= "philosopher",
  X.type =~= "Man"</code></pre>
                <p>
                    The comma <code>,</code> represents logical AND. All conditions must be
                    satisfied for the rule to succeed.
                </p>
                <h3>Example: Classical Logic</h3>
                <pre><code class="language-frisco">concept Man
  description = "rational animal"

entity SOCRATES: Man
  description = "philosopher"

mortal(X) :-
  X.type =~= "Man"

? mortal(SOCRATES)</code></pre>
            </section>

            <!-- Variables -->
            <section id="variables" class="lesson">
                <h2>Variables</h2>
                <p>
                    Variables in Frisco begin with uppercase letters and can be assigned
                    values or bound during execution.
                </p>
                <h3>Manual Variable Assignment</h3>
                <p>
                    You can assign values to variables directly using the <code>=</code> operator.
                    This is useful for storing values that you want to reuse across multiple queries.
                </p>
                <pre><code class="language-frisco">Name = "Socrates"
Greeting = "Hello"

? print(Greeting).
? print(", ").
? println(Name).</code></pre>
                <p>
                    Once assigned, variables persist throughout your session and can be used
                    in any query.
                </p>
                <h4>Practical Examples</h4>
                <p>
                    Variables can store any value - strings, entity names, or even field access results:
                </p>
                <pre><code class="language-frisco"># Store configuration values
MaxAttempts = "3"
DefaultGreeting = "Welcome"

# Store entity references
CurrentUser = "SOCRATES"
CurrentCity = "ATHENS"

# Use in queries
? println(CurrentUser).
? println(DefaultGreeting).</code></pre>
                <p>
                    In the REPL, you can set variables interactively without the <code>?</code> prefix:
                </p>
                <pre><code class="language-frisco">frisco> Name = "Aristotle"
frisco> println(Name)
Aristotle
True</code></pre>
                <p>
                    <strong>Note:</strong> Variable names must start with an uppercase letter to
                    distinguish them from predicates and lowercase identifiers.
                </p>
                <h3>Variable Binding</h3>
                <p>
                    Variables can also be bound dynamically using predicates:
                </p>
                <pre><code class="language-frisco">readln(Input)
println(Input)</code></pre>
                <h3>Variables in Rules</h3>
                <p>
                    Variables are used in rules to create general patterns:
                </p>
                <pre><code class="language-frisco">greet(Name) :-
  print("Hello, "),
  println(Name)

? greet("Aristotle")</code></pre>
                <p>
                    When a rule executes, variables are unified (matched and bound) with
                    values. This is the core mechanism of logic programming.
                </p>
            </section>

            <section id="unification" class="lesson">
                <h2>Unification & Equality</h2>
                <p>
                    Unification is how Frisco (and Prolog) makes two terms structurally identical by finding variable
                    bindings that satisfy both sides. It is bidirectional: variables can bind to atoms, numbers, lists,
                    or other variables. An occurs check prevents a variable from being unified with a term that
                    contains itself, avoiding infinite structures.
                </p>
                <p>
                    Use <code>=</code> to unify (and bind) variables, and <code>==</code> for exact structural equality
                    checks without binding.
                </p>
                <pre><code class="language-frisco">% Bind X to SOCRATES
? X = SOCRATES.
Bindings:
  X = SOCRATES
True

% Exact equality without binding
? SOCRATES == SOCRATES.
True

% Occurs check prevents infinite terms
? X = [1 | X].
False</code></pre>
                <p>
                    Use lowercase or uppercase variable names; anonymous variables are written as <code>_</code> when you
                    do not care about the binding.
                </p>
            </section>

            <section id="operators" class="lesson">
                <h2>Equality & Comparison Cheatsheet</h2>
                <ul>
                    <li><code>=</code>: Unification (binds variables, structural)</li>
                    <li><code>==</code>: Structural equality test (no binding)</li>
                    <li><code>is</code>: Evaluate arithmetic on the right, then unify left with the numeric result</li>
                    <li><code>=:=</code> / <code>=\=</code>: Numeric equality/inequality tests (no binding)</li>
                    <li><code>=~=</code>: Semantic match using embeddings (strings/lists)</li>
                </ul>
                <pre><code class="language-frisco">% Unify
? X = [1,2,3].
Bindings:
  X = [1, 2, 3]
True

% Structural equality
? [1,2] == [1,2].
True

% Arithmetic binding
? Sum is 3 + 4 * 2.
Bindings:
  Sum = 11
True

% Numeric comparison (no binding)
? 3 + 4 * 2 =:= 11.
True

% Semantic match
? "canine" =~= "dog".
True</code></pre>
            </section>

            <section id="operators-why" class="lesson">
                <h2>Why So Many Operators?</h2>
                <p>
                    Frisco inherits Prolog’s separation of concerns: unification is the core inference mechanism, while
                    arithmetic is an explicit side channel. Keeping operators distinct prevents ambiguity between
                    binding vs. testing vs. evaluating.
                </p>
                <ul>
                    <li><strong>Unification</strong> (<code>=</code>) is logic-level: it binds variables to any term and drives backtracking.</li>
                    <li><strong>Structural test</strong> (<code>==</code>) checks shapes without binding, useful in guards.</li>
                    <li><strong>Arithmetic eval</strong> (<code>is</code>) runs computations; separating it avoids implicit math during logic unification.</li>
                    <li><strong>Numeric comparisons</strong> (<code>=:=</code>, <code>=\=</code>) compare evaluated numbers without binding.</li>
                    <li><strong>Semantic match</strong> (<code>=~=</code>) is Frisco-specific and fuzzy; keeping it separate preserves deterministic equality.</li>
                </ul>
                <p>
                    This split lets the engine stay declarative and backtracking-safe, while arithmetic and semantic
                    reasoning remain explicit and predictable. “Backtracking-safe” means computations have no hidden
                    side effects that survive when the engine rewinds choice points: bindings and checks can be undone
                    cleanly, so exploring alternate solutions stays consistent.
                </p>
            </section>

            <section id="types" class="lesson">
                <h2>Terms & Types</h2>
                <p>Frisco terms are similar to Prolog terms:</p>
                <ul>
                    <li><strong>Atoms</strong>: lowercase identifiers or quoted strings (<code>man</code>, <code>"dog"</code>), immutable symbols.</li>
                    <li><strong>Numbers</strong>: integers/floats (<code>42</code>, <code>3.14</code>).</li>
                    <li><strong>Variables</strong>: names (any case) that can bind during unification; anonymous <code>_</code> is always fresh.</li>
                    <li><strong>Lists</strong>: <code>[a, b, c]</code> and head/tail <code>[H|T]</code>.</li>
                    <li><strong>Compound terms</strong>: functor + args, e.g., <code>likes(socrates, philosophy)</code>.</li>
                    <li><strong>Field access</strong>: <code>Entity.field</code> for KB lookups.</li>
                </ul>
                <p>Use type predicates to test: <code>atom/1</code>, <code>number/1</code>, <code>is_list/1</code>, <code>var/1</code>, <code>nonvar/1</code>.</p>
            </section>

            <section id="control" class="lesson">
                <h2>Negation, Cut, and Control</h2>
                <p>
                    Control operators steer backtracking: negation succeeds on failure, disjunction explores branches,
                    if-then-else commits to a branch, and cut prunes choice points to keep execution deterministic.
                </p>
                <ul>
                    <li><code>not(Goal)</code> or <code>\+ Goal</code>: negation as failure (succeeds when <code>Goal</code> fails).</li>
                    <li><code>Goal1 ; Goal2</code>: disjunction (OR). Tries left, then right.</li>
                    <li><code>Cond -> Then ; Else</code>: if-then-else; <code>Else</code> is optional.</li>
                    <li><code>!</code>: cut; commits to the current choice, pruning alternatives to the left.</li>
                </ul>
                <pre><code class="language-frisco">mortal(X) :- man(X), !, not(immortal(X)).

maybe_philosopher(X) :- scholar(X) ; writer(X).

sign(X) :- X > 0 -> println("positive") ; println("non-positive").</code></pre>
            </section>

            <section id="lists" class="lesson">
                <h2>Lists & Pattern Matching</h2>
                <p>
                    Lists are first-class with head/tail pattern matching. Use <code>[H|T]</code> to destructure.
                </p>
                <pre><code class="language-frisco">% Literals
[1, 2, 3]
[H|T] = [1, 2, 3].  % H = 1, T = [2, 3]

% Append
append([], L, L).
append([H|T1], L2, [H|T3]) :- append(T1, L2, T3).

? append([1,2], [3,4], R).
Bindings:
  R = [1, 2, 3, 4]
True</code></pre>
                <p>
                    Built-ins include <code>member/2</code>, <code>append/3</code>, <code>length/2</code>, <code>nth/3</code>, and
                    <code>reverse/2</code>.
                </p>
            </section>

            <section id="arithmetic" class="lesson">
                <h2>Arithmetic & Comparisons</h2>
                <p>
                    Numbers and arithmetic operators are supported. Use <code>is</code> to evaluate expressions and bind
                    results. Comparisons include <code>&lt;</code>, <code>&gt;</code>, <code>=&lt;</code>, <code>&gt;=</code>, <code>=:=</code>, and <code>=\=</code>.
                </p>
                <pre><code class="language-frisco">factorial(0, 1).
factorial(N, F) :-
  N > 0,
  N1 is N - 1,
  factorial(N1, F1),
  F is N * F1.

? factorial(5, R).
Bindings:
  R = 120
True

? 3 + 4 * 2 =:= 11.
True</code></pre>
            </section>

            <section id="solutions" class="lesson">
                <h2>Multiple Solutions & Collection</h2>
                <p>
                    The executor now backtracks to return all solutions. Use semicolons in the REPL to explore, or use
                    collection predicates.
                </p>
                <pre><code class="language-frisco">concept Person.
entity SOCRATES: Person.
entity PLATO: Person.
entity ARISTOTLE: Person.

? X.concept == Person.
Bindings:
  X = SOCRATES
  X = PLATO
  X = ARISTOTLE
True

? findall(X, X.concept == Person, People).
Bindings:
  People = [SOCRATES, PLATO, ARISTOTLE]
True</code></pre>
            </section>

            <section id="builtins" class="lesson">
                <h2>Built-ins Reference</h2>
                <p>Each built-in with its behavior and a quick example. Frisco is optimized for argument and ontology analysis, not numeric computation.</p>
                <h3>I/O</h3>
                <ul>
                    <li><code>println(X, ...)</code> — render arguments and print with newline.</li>
                    <li><code>print(X, ...)</code> — render arguments without newline.</li>
                    <li><code>readln(Var)</code> — read one line from stdin into <code>Var</code> (string).</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? print("Hello"), print(" "), println("world").
Hello world
True

? readln(Name), println(Name).
Alice
Alice
True</code></pre>
                </details>

                <h3>Lists</h3>
                <ul>
                    <li><code>member(Element, List)</code> — succeeds or generates elements.</li>
                    <li><code>append(A, B, Result)</code> — concatenate or split.</li>
                    <li><code>length(List, N)</code> — length of list.</li>
                    <li><code>nth(N, List, Element)</code> — 1-based access.</li>
                    <li><code>reverse(List, Reversed)</code> — reverse a list.</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? member(X, [a, b, c]).
Bindings:
  X = a
  X = b
  X = c
True

? append([1,2], [3,4], R).
Bindings:
  R = [1, 2, 3, 4]
True

? length([x,y,z], N).
Bindings:
  N = 3
True

? nth(2, [10,20,30], X).
Bindings:
  X = 20
True

? reverse([1,2,3], R).
Bindings:
  R = [3, 2, 1]
True</code></pre>
                </details>

                <h3>Arithmetic and comparisons</h3>
                <ul>
                    <li><code>is</code> — evaluate right-hand expression, bind left.</li>
                    <li><code>&lt;</code>, <code>&gt;</code>, <code>=&lt;</code>, <code>&gt;=</code>, <code>=:=</code>, <code>=\=</code> — numeric tests only.</li>
                    <li><code>=~=</code> — semantic match (fuzzy string/list comparison via embeddings).</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? Sum is 3 + 4 * 2.
Bindings:
  Sum = 11
True

? 7 =:= 3 + 4.
True

? 5 =\= 2 * 3.
True

? "canine" =~= "dog".
True</code></pre>
                </details>

                <h3>Type predicates</h3>
                <ul>
                    <li><code>is_unbound(X)</code> — succeeds if <code>X</code> is an unbound variable.</li>
                    <li><code>is_bound(X)</code> — succeeds if <code>X</code> is not a free variable.</li>
                    <li><code>is_atom(X)</code> — succeeds for atoms or string literals.</li>
                    <li><code>is_number(X)</code> — succeeds for numeric literals.</li>
                    <li><code>is_list(X)</code> — succeeds for lists.</li>
                    <li>Anonymous <code>_</code> is always fresh and unbound.</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">? is_unbound(X).
True

? X = foo, is_bound(X).
Bindings:
  X = foo
True

? is_atom("dog").
True

? is_number(42).
True

? is_list([1,2,3]).
True</code></pre>
                </details>

                <h3>Solutions</h3>
                <ul>
                    <li><code>findall(Template, Goal, List)</code> — collect all solutions of <code>Goal</code> for <code>Template</code> into <code>List</code> (returns <code>[]</code> if none).</li>
                    <li><code>setof(Template, Goal, List)</code> — collect like <code>findall</code> but remove duplicates (first-seen order here).</li>
                </ul>
                <details>
                  <summary>Examples</summary>
                  <pre><code class="language-frisco">likes(socrates, olives).
likes(plato, olives).
likes(plato, olives).  % duplicate

% All solutions (duplicates kept)
? findall(X, likes(X, olives), L).
Bindings:
  L = [socrates, plato, plato]
True

% Deduplicated collection
? setof(X, likes(X, olives), L).
Bindings:
  L = [socrates, plato]
True</code></pre>
                </details>

            </section>


            <section id="semantic" class="lesson">
                <h2>Semantic Matching</h2>
                <p>
                    One of Frisco's unique features is semantic matching using the
                    <code>=~=</code> operator.
                </p>
                <pre><code class="language-frisco">? SOCRATES.description =~= "thinker"</code></pre>
                <p>
                    This uses embedding models to determine if two phrases are semantically
                    similar, even if they use different words.
                </p>
                <h3>How It Works</h3>
                <p>
                    Frisco uses the BGE-Small-EN-V1.5 embedding model to convert text into
                    vector representations. It then calculates cosine similarity between
                    vectors.
                </p>
                <p>
                    The default threshold is 0.7, meaning a 70% similarity score is required
                    for a match.
                </p>
                <h3>Practical Example</h3>
                <pre><code class="language-frisco">concept Animal
  description = "living creature"

entity DOG: Animal
  description = "loyal companion"

friendly(X) :-
  X.description =~= "friendly pet"

? friendly(DOG)  # True - "loyal companion" is similar to "friendly pet"</code></pre>
            </section>

            <!-- Interactive Programs -->
            <section id="interactive" class="lesson">
                <h2>Interactive Programs</h2>
                <p>
                    Frisco supports interactive programs using <code>readln</code> for
                    user input.
                </p>
                <pre><code class="language-frisco">greet_user :-
  println("What is your name?"),
  readln(Name),
  print("Hello, "),
  print(Name),
  println("!"),
  println("Nice to meet you!")

? greet_user</code></pre>
                <p>
                    You can build more complex interactions:
                </p>
                <pre><code class="language-frisco">quiz :-
  println("What is the capital of Greece?"),
  readline(Answer),
  Answer.value =~= "Athens",
  println("Correct!")

? quiz</code></pre>
                <p>
                    Semantic matching makes interactive programs more forgiving - users don't
                    need to type exact answers!
                </p>
            </section>

            <!-- Using the REPL -->
            <section id="repl" class="lesson">
                <h2>Using the REPL</h2>
                <p>
                    Frisco includes a powerful REPL (Read-Eval-Print Loop) for interactive
                    development.
                </p>
                <h3>Starting the REPL</h3>
                <pre><code class="language-bash">npm run repl</code></pre>
                <h3>REPL Commands</h3>
                <ul>
                    <li><code>:help</code> - Show help message</li>
                    <li><code>:kb</code> - Display current knowledge base</li>
                    <li><code>:kb_save</code> - Save knowledge base to .frisco file</li>
                    <li><code>:kb_load</code> - Load knowledge base from file</li>
                    <li><code>:clear</code> - Clear screen</li>
                    <li><code>:quit</code> - Exit REPL</li>
                </ul>
                <h3>Multiline Input</h3>
                <p>
                    Press Enter to add new lines. Submit by:
                </p>
                <ul>
                    <li>Pressing Enter twice on an empty line</li>
                    <li>Ending your input with a period</li>
                    <li>Starting with <code>:</code> (commands submit immediately)</li>
                </ul>
                <h3>Navigation</h3>
                <ul>
                    <li>↑/↓ - Command history (single line mode)</li>
                    <li>Ctrl+↑/↓ - Command history (multiline mode)</li>
                    <li>←/→ - Move cursor</li>
                    <li>Ctrl+A/E - Jump to start/end of line</li>
                </ul>
                <h3>Try It!</h3>
                <p>
                    Open the REPL and try defining your own concepts, entities, and rules.
                    The REPL is the best way to experiment with Frisco!
                </p>
            </section>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="js/frisco-prism.js"></script>
    <script src="js/tour.js"></script>
</body>
</html>
