{
  "version": 3,
  "sources": ["../src/lexer.ts", "../src/parser.ts", "src/executor-web.ts", "src/semantic-matcher-web.ts", "src/frisco-web.ts"],
  "sourcesContent": ["export enum TokenType {\n  CONCEPT = 'CONCEPT',\n  ENTITY = 'ENTITY',\n  DESCRIPTION = 'DESCRIPTION',\n  ATTRIBUTES = 'ATTRIBUTES',\n  ESSENTIALS = 'ESSENTIALS',\n\n  ASSIGN = 'ASSIGN',\n  EQUAL_EQUAL = 'EQUAL_EQUAL',\n  SEMANTIC_MATCH = 'SEMANTIC_MATCH',\n  IMPLIES = 'IMPLIES',\n  BAR = 'BAR',\n  SEMICOLON = 'SEMICOLON',\n  CUT = 'CUT',\n  IF_THEN = 'IF_THEN',\n  NEGATION = 'NEGATION',\n  QUERY = 'QUERY',\n  DOT = 'DOT',\n  COMMA = 'COMMA',\n  COLON = 'COLON',\n\n  LPAREN = 'LPAREN',\n  RPAREN = 'RPAREN',\n  LBRACKET = 'LBRACKET',\n  RBRACKET = 'RBRACKET',\n\n  IDENTIFIER = 'IDENTIFIER',\n  STRING = 'STRING',\n\n  EOF = 'EOF',\n}\n\n\n\n\nexport type Token = {\n  type: TokenType;\n  value: string;\n  line: number;\n  column: number;\n};\n\nexport class Lexer {\n  private input: string;\n  private position = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(input: string) {\n    this.input = input;\n  }\n\n  private peek(offset = 0): string | null {\n    const pos = this.position + offset;\n    return pos < this.input.length ? this.input[pos] : null;\n  }\n\n  private advance(): string | null {\n    const char = this.peek();\n    if (char !== null) {\n      this.position++;\n      if (char === '\\n') {\n        this.line++;\n        this.column = 1;\n      } else {\n        this.column++;\n      }\n    }\n    return char;\n  }\n\n  private skipWhitespace(): void {\n    while (this.peek() !== null && /[ \\t\\r\\n]/.test(this.peek()!)) {\n      this.advance();\n    }\n  }\n\n  private skipComment(): void {\n    if (this.peek() === '#') {\n      while (this.peek() !== null && this.peek() !== '\\n') {\n        this.advance();\n      }\n    }\n  }\n\n  private readString(): string {\n    let result = '';\n    this.advance();\n\n    while (this.peek() !== null && this.peek() !== '\"') {\n      if (this.peek() === '\\\\') {\n        this.advance();\n        const escaped = this.advance();\n        if (escaped === 'n') result += '\\n';\n        else if (escaped === 't') result += '\\t';\n        else if (escaped === '\"') result += '\"';\n        else if (escaped === '\\\\') result += '\\\\';\n        else result += escaped ?? '';\n      } else {\n        result += this.advance();\n      }\n    }\n\n    this.advance();\n    return result;\n  }\n\n  private readIdentifier(): string {\n    let result = '';\n    while (this.peek() !== null && /[a-zA-Z0-9_]/.test(this.peek()!)) {\n      result += this.advance();\n    }\n    return result;\n  }\n\n  private getKeywordOrIdentifier(text: string): TokenType {\n    const keywords: { [key: string]: TokenType } = {\n      concept: TokenType.CONCEPT,\n      entity: TokenType.ENTITY,\n      description: TokenType.DESCRIPTION,\n      attributes: TokenType.ATTRIBUTES,\n      essentials: TokenType.ESSENTIALS,\n      not: TokenType.NEGATION,\n    };\n\n    if (keywords[text]) {\n      return keywords[text];\n    }\n\n    return TokenType.IDENTIFIER;\n  }\n\n  public tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (this.position < this.input.length) {\n      this.skipWhitespace();\n      if (this.peek() === '#') {\n        this.skipComment();\n        continue;\n      }\n      if (this.position >= this.input.length) break;\n\n      const char = this.peek();\n      const line = this.line;\n      const column = this.column;\n\n      if (char === '\"') {\n        const value = this.readString();\n        tokens.push({ type: TokenType.STRING, value, line, column });\n        continue;\n      }\n\n      if (char === '=' && this.peek(1) === '~' && this.peek(2) === '=') {\n        this.advance();\n        this.advance();\n        this.advance();\n        tokens.push({ type: TokenType.SEMANTIC_MATCH, value: '=~=', line, column });\n        continue;\n      }\n\n      if (char === ':' && this.peek(1) === '-') {\n        this.advance();\n        this.advance();\n        tokens.push({ type: TokenType.IMPLIES, value: ':-', line, column });\n        continue;\n      }\n\n      if (char === '-' && this.peek(1) === '>') {\n        this.advance();\n        this.advance();\n        tokens.push({ type: TokenType.IF_THEN, value: '->', line, column });\n        continue;\n      }\n\n\n      if (char === '=' && this.peek(1) === '=') {\n        this.advance();\n        this.advance();\n        tokens.push({ type: TokenType.EQUAL_EQUAL, value: '==', line, column });\n        continue;\n      }\n\n      const single: Record<string, TokenType> = {\n        '=': TokenType.ASSIGN,\n        '?': TokenType.QUERY,\n        '.': TokenType.DOT,\n        ',': TokenType.COMMA,\n        ':': TokenType.COLON,\n        '(': TokenType.LPAREN,\n        ')': TokenType.RPAREN,\n        '[': TokenType.LBRACKET,\n        ']': TokenType.RBRACKET,\n        '|': TokenType.BAR,\n        ';': TokenType.SEMICOLON,\n        '!': TokenType.CUT,\n      };\n\n\n      if (char && single[char]) {\n        tokens.push({ type: single[char], value: char, line, column });\n        this.advance();\n        continue;\n      }\n\n      if (char !== null && /[a-zA-Z_]/.test(char)) {\n        const text = this.readIdentifier();\n        const type = this.getKeywordOrIdentifier(text);\n        tokens.push({ type, value: text, line, column });\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${char}' at line ${line}, column ${column}`);\n    }\n\n    tokens.push({ type: TokenType.EOF, value: '', line: this.line, column: this.column });\n    return tokens;\n  }\n}\n", "import { Token, TokenType } from './lexer.js';\nimport * as AST from './ast.js';\n\nexport class Parser {\n  private tokens: Token[];\n  private position = 0;\n\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n  }\n\n  private peek(offset = 0): Token {\n    const pos = this.position + offset;\n    return pos < this.tokens.length ? this.tokens[pos] : this.tokens[this.tokens.length - 1];\n  }\n\n  private advance(): Token {\n    return this.tokens[this.position++];\n  }\n\n  private check(type: TokenType): boolean {\n    return this.peek().type === type;\n  }\n\n  private match(...types: TokenType[]): Token | null {\n    if (types.includes(this.peek().type)) {\n      return this.advance();\n    }\n    return null;\n  }\n\n  private expect(type: TokenType): Token {\n    const token = this.peek();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type} at line ${token.line}, column ${token.column}`);\n    }\n    return this.advance();\n  }\n\n  public parse(): AST.Program {\n    const statements: AST.Statement[] = [];\n    while (!this.check(TokenType.EOF)) {\n      statements.push(this.parseStatement());\n    }\n    return { type: 'Program', statements };\n  }\n\n  private parseStatement(): AST.Statement {\n    if (this.check(TokenType.CONCEPT)) return this.parseConceptDeclaration();\n    if (this.check(TokenType.ENTITY)) return this.parseEntityDeclaration();\n    if (this.check(TokenType.QUERY)) return this.parseQuery();\n    if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.LPAREN) {\n      // Check if it's a fact (ends with DOT) or rule (has IMPLIES)\n      const startPos = this.position;\n      try {\n        this.parsePredicateHead();\n        if (this.check(TokenType.DOT)) {\n          this.position = startPos;\n          const head = this.parsePredicateHead();\n          this.expect(TokenType.DOT);\n          return { type: 'RuleDeclaration', head, body: [] };\n        } else {\n          this.position = startPos;\n        }\n      } catch {\n        this.position = startPos;\n      }\n    }\n    return this.parseRuleOrAssignment();\n  }\n\n  private parseConceptDeclaration(): AST.ConceptDeclaration {\n    this.expect(TokenType.CONCEPT);\n    const name = this.expect(TokenType.IDENTIFIER).value;\n\n    let genus: string | null = null;\n    if (this.match(TokenType.COLON)) {\n      if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.COMMA) {\n        genus = this.expect(TokenType.IDENTIFIER).value;\n        this.expect(TokenType.COMMA);\n      } else {\n        genus = null;\n      }\n\n      // parse comma-separated properties\n      let description: string | null = null;\n      let attributes: string[] = [];\n      let essentials: string[] = [];\n\n      // parse first property\n      if (this.match(TokenType.DESCRIPTION)) {\n        this.expect(TokenType.ASSIGN);\n        description = this.expect(TokenType.STRING).value;\n      } else if (this.match(TokenType.ATTRIBUTES)) {\n        this.expect(TokenType.ASSIGN);\n        attributes = this.parseStringArray();\n      } else if (this.match(TokenType.ESSENTIALS)) {\n        this.expect(TokenType.ASSIGN);\n        essentials = this.parseIdentifierOrStringArray();\n      }\n\n      // then comma-separated\n      while (this.match(TokenType.COMMA)) {\n        if (this.match(TokenType.DESCRIPTION)) {\n          this.expect(TokenType.ASSIGN);\n          description = this.expect(TokenType.STRING).value;\n        } else if (this.match(TokenType.ATTRIBUTES)) {\n          this.expect(TokenType.ASSIGN);\n          attributes = this.parseStringArray();\n        } else if (this.match(TokenType.ESSENTIALS)) {\n          this.expect(TokenType.ASSIGN);\n          essentials = this.parseIdentifierOrStringArray();\n        }\n      }\n\n      this.expect(TokenType.DOT);\n      return { type: 'ConceptDeclaration', name, genus, description, attributes, essentials };\n    }\n\n    // old style fallback, but we can remove it since we're updating\n    this.match(TokenType.DOT);\n    return { type: 'ConceptDeclaration', name, genus: null, description: null, attributes: [], essentials: [] };\n  }\n\n  private parseEntityDeclaration(): AST.EntityDeclaration {\n    this.expect(TokenType.ENTITY);\n    const name = this.expect(TokenType.IDENTIFIER).value;\n    this.expect(TokenType.COLON);\n    const conceptType = this.expect(TokenType.IDENTIFIER).value;\n\n    let description: string | null = null;\n    const properties = new Map<string, string>();\n\n    // Support comma-separated properties: entity NAME: CONCEPT, prop = \"value\", ...\n    if (this.match(TokenType.COMMA)) {\n      // Parse first property\n      if (this.match(TokenType.DESCRIPTION)) {\n        this.expect(TokenType.ASSIGN);\n        description = this.expect(TokenType.STRING).value;\n      } else if (this.check(TokenType.IDENTIFIER)) {\n        const propName = this.advance().value;\n        this.expect(TokenType.ASSIGN);\n        const propValue = this.expect(TokenType.STRING).value;\n        properties.set(propName, propValue);\n      }\n\n      // Parse remaining properties\n      while (this.match(TokenType.COMMA)) {\n        if (this.match(TokenType.DESCRIPTION)) {\n          this.expect(TokenType.ASSIGN);\n          description = this.expect(TokenType.STRING).value;\n        } else if (this.check(TokenType.IDENTIFIER)) {\n          const propName = this.advance().value;\n          this.expect(TokenType.ASSIGN);\n          const propValue = this.expect(TokenType.STRING).value;\n          properties.set(propName, propValue);\n        }\n      }\n    }\n\n    this.match(TokenType.DOT);\n\n    return { type: 'EntityDeclaration', name, conceptType, description, properties };\n  }\n\n  private parseRuleOrAssignment(): AST.RuleDeclaration | AST.Assignment {\n    const first = this.peek();\n    const second = this.peek(1);\n    if (first.type === TokenType.IDENTIFIER && second.type === TokenType.ASSIGN) {\n      return this.parseAssignment();\n    }\n    return this.parseRuleDeclaration();\n  }\n\n  private parseRuleDeclaration(): AST.RuleDeclaration {\n    const head = this.parsePredicateHead();\n    this.expect(TokenType.IMPLIES);\n    const body = this.parseGoalBody();\n    this.match(TokenType.DOT);\n    return { type: 'RuleDeclaration', head, body };\n  }\n\n  private parsePredicateHead(): AST.PredicateHead {\n    const name = this.expect(TokenType.IDENTIFIER).value;\n    const parameters: AST.Term[] = [];\n    if (this.match(TokenType.LPAREN)) {\n      if (!this.check(TokenType.RPAREN)) {\n        parameters.push(this.parseTerm());\n        while (this.match(TokenType.COMMA)) {\n          parameters.push(this.parseTerm());\n        }\n      }\n      this.expect(TokenType.RPAREN);\n    }\n    return { name, parameters };\n  }\n\n  private parseQuery(): AST.Query {\n    this.expect(TokenType.QUERY);\n    const body = this.parseGoalBody();\n    this.match(TokenType.DOT);\n    return { type: 'Query', body };\n  }\n\n  private parseGoalBody(): AST.Condition[] {\n    return this.parseDisjunction();\n  }\n\n  private parseDisjunction(): AST.Condition[] {\n    let branches: AST.Condition[][] = [this.parseIfThenElse()];\n    while (this.match(TokenType.SEMICOLON)) {\n      branches.push(this.parseIfThenElse());\n    }\n    if (branches.length === 1) return branches[0];\n    let acc: AST.Condition[] = branches[0];\n    for (let i = 1; i < branches.length; i++) {\n      acc = [{ type: 'Disjunction', left: acc, right: branches[i] } as AST.Condition];\n    }\n    return acc;\n  }\n\n  private parseIfThenElse(): AST.Condition[] {\n    const condSeq = this.parseConjunction();\n    if (this.match(TokenType.IF_THEN)) {\n      const thenSeq = this.parseConjunction();\n      let elseSeq: AST.Condition[] = [];\n      if (this.match(TokenType.SEMICOLON)) {\n        elseSeq = this.parseConjunction();\n      }\n      return [{ type: 'IfThenElse', condition: condSeq, thenBranch: thenSeq, elseBranch: elseSeq } as AST.Condition];\n    }\n    return condSeq;\n  }\n\n  private parseConjunction(): AST.Condition[] {\n    const seq: AST.Condition[] = [];\n    seq.push(this.parseAtomicCondition());\n    while (this.match(TokenType.COMMA)) {\n      seq.push(this.parseAtomicCondition());\n    }\n    return seq;\n  }\n\n  private parseAtomicCondition(): AST.Condition {\n    if (this.match(TokenType.CUT)) return { type: 'Cut' };\n\n    if (this.match(TokenType.NEGATION)) {\n      const goals = this.parseAtomicCondition();\n      return { type: 'Negation', goals: [goals] };\n    }\n\n    if (this.check(TokenType.IDENTIFIER) && this.peek(1).type === TokenType.LPAREN) {\n      return this.parsePredicateCall();\n    }\n\n    const leftTerm = this.parseTerm();\n\n    if (this.match(TokenType.SEMANTIC_MATCH)) {\n      const right = this.parseTerm();\n      return { type: 'SemanticMatch', left: leftTerm, right };\n    }\n\n    const equalityToken = this.match(TokenType.EQUAL_EQUAL) || this.match(TokenType.ASSIGN);\n    if (equalityToken) {\n      const right = this.parseTerm();\n      return {\n        type: 'Equality',\n        operator: equalityToken.type === TokenType.EQUAL_EQUAL ? '==' : '=',\n        left: leftTerm,\n        right,\n      };\n    }\n\n    if (leftTerm.type === 'CompoundTerm') {\n      return { type: 'PredicateCall', name: leftTerm.functor, arguments: leftTerm.args };\n    }\n\n    throw new Error(`Unexpected condition at line ${this.peek().line}, column ${this.peek().column}: unexpected token ${this.peek().type} '${this.peek().value}'`);\n  }\n\n  private parsePredicateCall(): AST.PredicateCall {\n    const name = this.expect(TokenType.IDENTIFIER).value;\n    this.expect(TokenType.LPAREN);\n    const args: AST.Term[] = [];\n    if (!this.check(TokenType.RPAREN)) {\n      args.push(this.parseTerm());\n      while (this.match(TokenType.COMMA)) {\n        args.push(this.parseTerm());\n      }\n    }\n    this.expect(TokenType.RPAREN);\n    return { type: 'PredicateCall', name, arguments: args };\n  }\n\n  private parseExpression(): AST.Term {\n    return this.parsePrimary();\n  }\n\n  private parsePrimary(): AST.Term {\n    if (this.check(TokenType.STRING)) {\n      const value = this.advance().value;\n      return { type: 'StringLiteral', value };\n    }\n\n    if (this.check(TokenType.LBRACKET)) {\n      return this.parseList();\n    }\n\n    if (this.check(TokenType.IDENTIFIER)) {\n      const name = this.advance().value;\n      if (this.check(TokenType.LPAREN)) {\n        this.advance();\n        const args: AST.Term[] = [];\n        if (!this.check(TokenType.RPAREN)) {\n          args.push(this.parseTerm());\n          while (this.match(TokenType.COMMA)) {\n            args.push(this.parseTerm());\n          }\n        }\n        this.expect(TokenType.RPAREN);\n        return { type: 'CompoundTerm', functor: name, args };\n      }\n      if (this.check(TokenType.DOT)) {\n        this.advance();\n        const field = this.advance().value;\n        return { type: 'FieldAccess', object: name, field };\n      }\n      if (name === '_') {\n        return { type: 'Variable', name, anonymous: true };\n      }\n      if (/^[a-z]/.test(name)) {\n        return { type: 'Variable', name };\n      }\n      return { type: 'Atom', value: name };\n    }\n\n    if (this.check(TokenType.LPAREN)) {\n      this.advance();\n      const expr = this.parseExpression();\n      this.expect(TokenType.RPAREN);\n      return expr;\n    }\n\n    throw new Error(`Unexpected token ${this.peek().type} at line ${this.peek().line}, column ${this.peek().column}`);\n  }\n\n  private parseTerm(): AST.Term {\n    return this.parseExpression();\n  }\n\n  private parseList(): AST.List {\n    this.expect(TokenType.LBRACKET);\n    const elements: AST.Term[] = [];\n    let tail: AST.Term | null | undefined = null;\n\n    if (!this.check(TokenType.RBRACKET)) {\n      elements.push(this.parseTerm());\n      while (this.match(TokenType.COMMA)) {\n        elements.push(this.parseTerm());\n      }\n      if (this.match(TokenType.BAR)) {\n        tail = this.parseTerm();\n      }\n    }\n\n    this.expect(TokenType.RBRACKET);\n    return { type: 'List', elements, tail };\n  }\n\n  private parseAssignment(): AST.Assignment {\n    const variable = this.expect(TokenType.IDENTIFIER).value;\n    this.expect(TokenType.ASSIGN);\n    const valueToken = this.advance();\n    const value = valueToken.value;\n    return { type: 'Assignment', variable, value };\n  }\n\n  private parseStringArray(): string[] {\n    this.expect(TokenType.LBRACKET);\n    const items: string[] = [];\n    if (!this.check(TokenType.RBRACKET)) {\n      items.push(this.expect(TokenType.STRING).value);\n      while (this.match(TokenType.COMMA)) {\n        if (this.check(TokenType.RBRACKET)) break;\n        items.push(this.expect(TokenType.STRING).value);\n      }\n    }\n    this.expect(TokenType.RBRACKET);\n    return items;\n  }\n\n  private parseIdentifierOrStringArray(): string[] {\n    this.expect(TokenType.LBRACKET);\n    const items: string[] = [];\n    if (!this.check(TokenType.RBRACKET)) {\n      const first = this.advance();\n      items.push(first.value);\n      while (this.match(TokenType.COMMA)) {\n        if (this.check(TokenType.RBRACKET)) break;\n        items.push(this.advance().value);\n      }\n    }\n    this.expect(TokenType.RBRACKET);\n    return items;\n  }\n}\n", "// Browser-compatible Executor for Frisco\nimport * as AST from '../../src/ast';\nimport { SemanticMatcherWeb } from './semantic-matcher-web';\n\ntype Substitution = Map<string, AST.Term>;\n\ntype KnowledgeBase = {\n  concepts: Map<string, AST.ConceptDeclaration>;\n  entities: Map<string, AST.EntityDeclaration>;\n  rules: AST.RuleDeclaration[];\n};\n\nexport type OutputHandler = (message: string) => void;\nexport type InputHandler = (prompt?: string) => Promise<string>;\n\nconst CUT_MARKER = '__CUT__';\n\nexport class ExecutorWeb {\n  private kb: KnowledgeBase = {\n    concepts: new Map(),\n    entities: new Map(),\n    rules: [],\n  };\n  private globalBindings: Substitution = new Map();\n  private matcher: SemanticMatcherWeb;\n  private outputHandler: OutputHandler;\n  private inputHandler: InputHandler;\n  private printBuffer: string = '';\n\n  constructor(\n    threshold: number,\n    matcher: SemanticMatcherWeb,\n    outputHandler: OutputHandler,\n    inputHandler: InputHandler\n  ) {\n    this.matcher = matcher;\n    this.outputHandler = outputHandler;\n    this.inputHandler = inputHandler;\n  }\n\n  async execute(program: AST.Program): Promise<void> {\n    // Don't reset KB between executions to maintain state in REPL\n    for (const statement of program.statements) {\n      switch (statement.type) {\n        case 'ConceptDeclaration':\n          this.kb.concepts.set(statement.name, statement);\n          break;\n        case 'EntityDeclaration':\n          this.kb.entities.set(statement.name, statement);\n          break;\n        case 'RuleDeclaration':\n          this.kb.rules.push(statement);\n          break;\n        case 'Assignment': {\n          this.globalBindings.set(statement.variable, { type: 'StringLiteral', value: statement.value });\n          break;\n        }\n      }\n    }\n\n    for (const statement of program.statements) {\n      if (statement.type === 'Query') {\n        await this.executeQuery(statement);\n      }\n    }\n\n    // Flush any remaining print buffer\n    if (this.printBuffer) {\n      this.outputHandler(this.printBuffer);\n      this.printBuffer = '';\n    }\n  }\n\n  private async executeQuery(query: AST.Query): Promise<void> {\n    const initialSubst = new Map(this.globalBindings);\n    let solutionCount = 0;\n\n    for await (const solution of this.evaluateGoals(query.body, initialSubst)) {\n      solutionCount++;\n      this.outputSolution(solution, query.body);\n    }\n\n    const hasSideEffects = query.body.some(condition => {\n      if (condition.type === 'PredicateCall') {\n        return ['print', 'println', 'readln'].includes(condition.name);\n      }\n      return false;\n    });\n\n    if (!hasSideEffects) {\n      if (solutionCount === 0) {\n        this.outputHandler('False');\n      } else {\n        this.outputHandler('True');\n      }\n    }\n  }\n\n  public async *evaluateGoals(goals: AST.Condition[], subst: Substitution): AsyncGenerator<Substitution> {\n    if (goals.length === 0) {\n      yield subst;\n      return;\n    }\n\n    const [first, ...rest] = goals;\n    for await (const nextSubst of this.evaluateCondition(first, subst)) {\n      if (this.hasCut(nextSubst)) {\n        yield* this.evaluateGoals(rest, nextSubst);\n        return;\n      }\n      yield* this.evaluateGoals(rest, nextSubst);\n    }\n  }\n\n  private async *evaluateCondition(condition: AST.Condition, subst: Substitution): AsyncGenerator<Substitution> {\n    switch (condition.type) {\n      case 'PredicateCall':\n        yield* this.evaluatePredicate(condition, subst);\n        return;\n      case 'SemanticMatch': {\n        const success = await this.evaluateSemanticMatch(condition, subst);\n        if (success) yield subst;\n        return;\n      }\n      case 'Equality': {\n        if (condition.operator === '=') {\n          const unified = this.unify(condition.left, condition.right, subst);\n          if (unified) yield unified;\n        } else {\n          const left = this.deref(condition.left, subst);\n          const right = this.deref(condition.right, subst);\n          if (this.termsEqual(left, right)) yield subst;\n        }\n        return;\n      }\n      case 'Negation': {\n        let succeeded = false;\n        for await (const _ of this.evaluateGoals(condition.goals, subst)) {\n          succeeded = true;\n          break;\n        }\n        if (!succeeded) yield subst;\n        return;\n      }\n      case 'Disjunction': {\n        for await (const leftSubst of this.evaluateGoals(condition.left, subst)) {\n          yield leftSubst;\n          if (this.hasCut(leftSubst)) return;\n        }\n        for await (const rightSubst of this.evaluateGoals(condition.right, subst)) {\n          yield rightSubst;\n          if (this.hasCut(rightSubst)) return;\n        }\n        return;\n      }\n      case 'IfThenElse': {\n        let thenSatisfied = false;\n        for await (const condSubst of this.evaluateGoals(condition.condition, subst)) {\n          thenSatisfied = true;\n          for await (const thenSubst of this.evaluateGoals(condition.thenBranch, condSubst)) {\n            yield thenSubst;\n            if (this.hasCut(thenSubst)) return;\n          }\n          return;\n        }\n        if (!thenSatisfied) {\n          for await (const elseSubst of this.evaluateGoals(condition.elseBranch, subst)) {\n            yield elseSubst;\n            if (this.hasCut(elseSubst)) return;\n          }\n        }\n        return;\n      }\n      case 'Cut': {\n        yield this.markCut(subst);\n        return;\n      }\n    }\n  }\n\n  private async *evaluatePredicate(call: AST.PredicateCall, subst: Substitution): AsyncGenerator<Substitution> {\n    // Handle builtins\n    const builtinResult = this.runBuiltin(call.name, call.arguments, subst);\n    if (builtinResult) {\n      yield* builtinResult;\n      return;\n    }\n\n    for (const rule of this.kb.rules) {\n      if (rule.head.name !== call.name) continue;\n      if (rule.head.parameters.length !== call.arguments.length) continue;\n\n      const freshRule = this.refreshRuleVariables(rule);\n      let currentSubst: Substitution | null = new Map(subst);\n      for (let i = 0; i < call.arguments.length; i++) {\n        if (!currentSubst) break;\n        currentSubst = this.unify(call.arguments[i], freshRule.head.parameters[i], currentSubst);\n      }\n      if (!currentSubst) continue;\n\n      for await (const result of this.evaluateGoals(freshRule.body, currentSubst)) {\n        yield result;\n        if (this.hasCut(result)) return;\n      }\n    }\n  }\n\n  private runBuiltin(name: string, args: AST.Term[], subst: Substitution): AsyncGenerator<Substitution> | null {\n    const self = this;\n    switch (name) {\n      case 'print':\n        return (async function* () {\n          const rendered = args.map((a) => self.termToPrintable(self.deref(a, subst), subst)).join('');\n          self.printBuffer += rendered;\n          yield subst;\n        })();\n\n      case 'println':\n        return (async function* () {\n          const rendered = args.map((a) => self.termToPrintable(self.deref(a, subst), subst)).join('');\n          self.printBuffer += rendered;\n          self.outputHandler(self.printBuffer);\n          self.printBuffer = '';\n          yield subst;\n        })();\n\n      case 'readln':\n        return (async function* () {\n          if (args.length !== 1) return;\n          const target = self.deref(args[0], subst);\n          if (target.type !== 'Variable') return;\n          const input = await self.inputHandler('');\n          const next = new Map(subst);\n          next.set(target.name, { type: 'StringLiteral', value: input });\n          yield next;\n        })();\n\n      case 'member':\n        return (async function* () {\n          if (args.length !== 2) return;\n          const item = args[0];\n          const listTerm = self.deref(args[1], subst);\n          if (listTerm.type !== 'List') return;\n          for (const element of listTerm.elements) {\n            const unified = self.unify(item, element, subst);\n            if (unified) yield unified;\n          }\n        })();\n\n      case 'append':\n        return (async function* () {\n          if (args.length !== 3) return;\n          const [a, b, result] = args.map((t) => self.deref(t, subst));\n          if (a.type === 'List' && b.type === 'List') {\n            const elements = [...a.elements, ...b.elements];\n            const list: AST.List = { type: 'List', elements, tail: null };\n            const unified = self.unify(result, list, subst);\n            if (unified) yield unified;\n          }\n        })();\n\n      case 'reverse':\n        return (async function* () {\n          if (args.length !== 2) return;\n          const listTerm = self.deref(args[0], subst);\n          if (listTerm.type !== 'List') return;\n          const reversed: AST.List = { type: 'List', elements: [...listTerm.elements].reverse(), tail: null };\n          const unified = self.unify(args[1], reversed, subst);\n          if (unified) yield unified;\n        })();\n\n      case 'is_list':\n        return (async function* () {\n          if (args.length !== 1) return;\n          const t = self.deref(args[0], subst);\n          if (t.type === 'List') yield subst;\n        })();\n\n      case 'similar_attr':\n        return (async function* () {\n          if (args.length !== 3) return;\n          const dim = self.termToString(self.deref(args[0], subst), subst);\n          const a = self.termToString(self.deref(args[1], subst), subst).replace(/^\"|\"$/g, '');\n          const b = self.termToString(self.deref(args[2], subst), subst).replace(/^\"|\"$/g, '');\n          const ok = await self.matcher.matchWithThreshold(a, b, dim);\n          if (ok) yield subst;\n        })();\n\n      case 'is_unbound':\n        return (async function* () {\n          if (args.length !== 1) return;\n          const t = self.deref(args[0], subst);\n          if (t.type === 'Variable') yield subst;\n        })();\n\n      case 'is_bound':\n        return (async function* () {\n          if (args.length !== 1) return;\n          const t = self.deref(args[0], subst);\n          if (t.type !== 'Variable') yield subst;\n        })();\n\n      case 'is_atom':\n        return (async function* () {\n          if (args.length !== 1) return;\n          const t = self.deref(args[0], subst);\n          if (t.type === 'Atom' || t.type === 'StringLiteral') yield subst;\n        })();\n\n      case 'findall':\n        return (async function* () {\n          if (args.length !== 3) return;\n          const [template, goalTerm, listVar] = args;\n          const goalCondition = self.termToGoal(goalTerm);\n          const results: AST.Term[] = [];\n          for await (const s of self.evaluateGoals([goalCondition], new Map(subst))) {\n            results.push(self.deref(template, s));\n          }\n          const list: AST.List = { type: 'List', elements: results, tail: null };\n          const unified = self.unify(listVar, list, subst);\n          if (unified) yield unified;\n        })();\n\n      case 'setof':\n        return (async function* () {\n          if (args.length !== 3) return;\n          const [template, goalTerm, listVar] = args;\n          const goalCondition = self.termToGoal(goalTerm);\n          const results: string[] = [];\n          const templTerms: AST.Term[] = [];\n          for await (const s of self.evaluateGoals([goalCondition], new Map(subst))) {\n            const value = self.termToString(self.deref(template, s), s);\n            results.push(value);\n            templTerms.push(self.deref(template, s));\n          }\n          const unique: AST.Term[] = [];\n          const seen = new Set<string>();\n          templTerms.forEach((t, i) => {\n            if (!seen.has(results[i])) {\n              seen.add(results[i]);\n              unique.push(t);\n            }\n          });\n          const list: AST.List = { type: 'List', elements: unique, tail: null };\n          const unified = self.unify(listVar, list, subst);\n          if (unified) yield unified;\n        })();\n\n      default:\n        return null;\n    }\n  }\n\n  private termToGoal(term: AST.Term): AST.Condition {\n    if (term.type === 'CompoundTerm') {\n      return { type: 'PredicateCall', name: term.functor, arguments: term.args };\n    }\n    if (term.type === 'Atom') {\n      return { type: 'PredicateCall', name: term.value, arguments: [] };\n    }\n    throw new Error('Goal term must be a callable term');\n  }\n\n  private refreshRuleVariables(rule: AST.RuleDeclaration): AST.RuleDeclaration {\n    const suffix = `__${Math.random().toString(36).slice(2)}`;\n    const renameTerm = (term: AST.Term): AST.Term => {\n      const t = this.deref(term, new Map());\n      switch (t.type) {\n        case 'Variable':\n          return { ...t, name: `${t.name}${suffix}` };\n        case 'List':\n          return { type: 'List', elements: t.elements.map(renameTerm), tail: t.tail ? renameTerm(t.tail) : t.tail };\n        case 'CompoundTerm':\n          return { type: 'CompoundTerm', functor: t.functor, args: t.args.map(renameTerm) };\n        default:\n          return t;\n      }\n    };\n\n    const head: AST.PredicateHead = {\n      name: rule.head.name,\n      parameters: rule.head.parameters.map(renameTerm),\n    };\n\n    const body = rule.body.map((cond) => this.renameConditionVariables(cond, renameTerm));\n    return { type: 'RuleDeclaration', head, body };\n  }\n\n  private renameConditionVariables(cond: AST.Condition, rename: (term: AST.Term) => AST.Term): AST.Condition {\n    switch (cond.type) {\n      case 'PredicateCall':\n        return { type: 'PredicateCall', name: cond.name, arguments: cond.arguments.map(rename) };\n      case 'SemanticMatch':\n        return { type: 'SemanticMatch', left: rename(cond.left), right: rename(cond.right) };\n      case 'Equality':\n        return { type: 'Equality', operator: cond.operator, left: rename(cond.left), right: rename(cond.right) };\n      case 'Negation':\n        return { type: 'Negation', goals: cond.goals.map((g) => this.renameConditionVariables(g, rename)) };\n      case 'Disjunction':\n        return { type: 'Disjunction', left: cond.left.map((g) => this.renameConditionVariables(g, rename)), right: cond.right.map((g) => this.renameConditionVariables(g, rename)) };\n      case 'IfThenElse':\n        return {\n          type: 'IfThenElse',\n          condition: cond.condition.map((g) => this.renameConditionVariables(g, rename)),\n          thenBranch: cond.thenBranch.map((g) => this.renameConditionVariables(g, rename)),\n          elseBranch: cond.elseBranch.map((g) => this.renameConditionVariables(g, rename)),\n        };\n      case 'Cut':\n        return { type: 'Cut' };\n    }\n  }\n\n  public deref(term: AST.Term, subst: Substitution): AST.Term {\n    if (term.type === 'Variable' && !term.anonymous) {\n      const bound = subst.get(term.name);\n      if (bound) return this.deref(bound, subst);\n    }\n    return term;\n  }\n\n  private occurs(varName: string, term: AST.Term, subst: Substitution): boolean {\n    const t = this.deref(term, subst);\n    if (t.type === 'Variable') return t.name === varName;\n    if (t.type === 'List') {\n      return t.elements.some((e) => this.occurs(varName, e, subst)) || (t.tail ? this.occurs(varName, t.tail, subst) : false);\n    }\n    if (t.type === 'CompoundTerm') return t.args.some((a) => this.occurs(varName, a, subst));\n    return false;\n  }\n\n  public unify(a: AST.Term, b: AST.Term, subst: Substitution): Substitution | null {\n    const left = this.resolveField(this.deref(a, subst), subst);\n    const right = this.resolveField(this.deref(b, subst), subst);\n\n    if (left.type === 'Variable' && left.anonymous) return subst;\n    if (right.type === 'Variable' && right.anonymous) return subst;\n\n    if (left.type === 'Variable') {\n      if (this.occurs(left.name, right, subst)) return null;\n      const next = new Map(subst);\n      next.set(left.name, right);\n      return next;\n    }\n    if (right.type === 'Variable') {\n      if (this.occurs(right.name, left, subst)) return null;\n      const next = new Map(subst);\n      next.set(right.name, left);\n      return next;\n    }\n\n    if (left.type === 'Atom' && right.type === 'Atom') return left.value === right.value ? subst : null;\n    if (left.type === 'StringLiteral' && right.type === 'StringLiteral') return left.value === right.value ? subst : null;\n\n    if (left.type === 'List' && right.type === 'List') {\n      if (left.elements.length > 0 && right.elements.length > 0) {\n        const [h1, ...t1] = left.elements;\n        const [h2, ...t2] = right.elements;\n        const tail1 = left.tail ?? (t1.length ? { type: 'List', elements: t1, tail: null } as AST.List : null);\n        const tail2 = right.tail ?? (t2.length ? { type: 'List', elements: t2, tail: null } as AST.List : null);\n        const s1 = this.unify(h1, h2, subst);\n        if (!s1) return null;\n        const s2 = this.unify(tail1 || { type: 'List', elements: [], tail: null }, tail2 || { type: 'List', elements: [], tail: null }, s1);\n        return s2;\n      }\n      if (!left.tail && !right.tail && left.elements.length === right.elements.length) {\n        let current: Substitution | null = subst;\n        for (let i = 0; i < left.elements.length; i++) {\n          current = current && this.unify(left.elements[i], right.elements[i], current);\n        }\n        return current;\n      }\n      return null;\n    }\n\n    if (left.type === 'CompoundTerm' && right.type === 'CompoundTerm') {\n      if (left.functor !== right.functor || left.args.length !== right.args.length) return null;\n      let current: Substitution | null = subst;\n      for (let i = 0; i < left.args.length; i++) {\n        current = current && this.unify(left.args[i], right.args[i], current);\n      }\n      return current;\n    }\n\n    return null;\n  }\n\n  private termsEqual(a: AST.Term, b: AST.Term): boolean {\n    if (a.type !== b.type) return false;\n    switch (a.type) {\n      case 'Variable':\n        return b.type === 'Variable' && a.name === (b as AST.Variable).name;\n      case 'Atom':\n        return (b as AST.Atom).value === a.value;\n      case 'StringLiteral':\n        return (b as AST.StringLiteral).value === a.value;\n      case 'List': {\n        const lb = b as AST.List;\n        if (a.elements.length !== lb.elements.length) return false;\n        for (let i = 0; i < a.elements.length; i++) {\n          if (!this.termsEqual(a.elements[i], lb.elements[i])) return false;\n        }\n        if (a.tail && lb.tail) return this.termsEqual(a.tail, lb.tail);\n        return !a.tail && !lb.tail;\n      }\n      case 'CompoundTerm': {\n        const cb = b as AST.CompoundTerm;\n        if (a.functor !== cb.functor || a.args.length !== cb.args.length) return false;\n        return a.args.every((arg, i) => this.termsEqual(arg, cb.args[i]));\n      }\n      case 'FieldAccess': {\n        const fb = b as AST.FieldAccess;\n        return a.object === fb.object && a.field === fb.field;\n      }\n    }\n  }\n\n  private resolveField(term: AST.Term, subst: Substitution): AST.Term {\n    if (term.type !== 'FieldAccess') return term;\n    const value = this.getFieldValue(term.object, term.field);\n    if (value === null) return term;\n    if (Array.isArray(value)) {\n      return { type: 'List', elements: value.map((v) => ({ type: 'StringLiteral', value: v } as AST.StringLiteral)), tail: null };\n    }\n    return { type: 'StringLiteral', value: value.toString() } as AST.StringLiteral;\n  }\n\n  private async evaluateSemanticMatch(condition: AST.SemanticMatchCondition, subst: Substitution): Promise<boolean> {\n    const leftVal = await this.termToValue(this.deref(condition.left, subst), subst);\n    const rightVal = await this.termToValue(this.deref(condition.right, subst), subst);\n    if (typeof leftVal === 'string' && typeof rightVal === 'string') return this.matcher.match(leftVal, rightVal);\n    if (Array.isArray(leftVal) && typeof rightVal === 'string') return this.matcher.match(leftVal, rightVal);\n    return false;\n  }\n\n  private async termToValue(term: AST.Term, subst: Substitution): Promise<string | string[] | null> {\n    const t = this.resolveField(this.deref(term, subst), subst);\n    switch (t.type) {\n      case 'StringLiteral':\n        return t.value;\n      case 'Atom':\n        return t.value;\n      case 'List':\n        return t.elements.map((e) => this.termToValueSync(e, subst)).map((v) => (v === null ? '' : String(v)));\n      case 'Variable':\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  private termToValueSync(term: AST.Term, subst: Substitution): string | null {\n    const t = this.resolveField(this.deref(term, subst), subst);\n    switch (t.type) {\n      case 'StringLiteral':\n        return t.value;\n      case 'Atom':\n        return t.value;\n      default:\n        return null;\n    }\n  }\n\n  public termToString(term: AST.Term, subst: Substitution): string {\n    const t = this.deref(term, subst);\n    switch (t.type) {\n      case 'Variable':\n        return t.name;\n      case 'Atom':\n        return t.value;\n      case 'StringLiteral':\n        return `\"${t.value}\"`;\n      case 'List': {\n        const elements = t.elements.map((e) => this.termToString(e, subst));\n        const tail = t.tail ? `| ${this.termToString(t.tail, subst)}` : '';\n        return `[${elements.join(', ')}${tail ? ' ' + tail : ''}]`;\n      }\n      case 'CompoundTerm':\n        return `${t.functor}(${t.args.map((a) => this.termToString(a, subst)).join(', ')})`;\n      case 'FieldAccess':\n        return `${t.object}.${t.field}`;\n    }\n  }\n\n  // For print/println - outputs raw values without quotes\n  public termToPrintable(term: AST.Term, subst: Substitution): string {\n    const t = this.deref(term, subst);\n    switch (t.type) {\n      case 'Variable':\n        return t.name;\n      case 'Atom':\n        return t.value;\n      case 'StringLiteral':\n        return t.value;  // No quotes for printing\n      case 'List': {\n        const elements = t.elements.map((e) => this.termToPrintable(e, subst));\n        return `[${elements.join(', ')}]`;\n      }\n      case 'CompoundTerm':\n        return `${t.functor}(${t.args.map((a) => this.termToPrintable(a, subst)).join(', ')})`;\n      case 'FieldAccess':\n        return `${t.object}.${t.field}`;\n    }\n  }\n\n  private outputSolution(subst: Substitution, goals: AST.Condition[]): void {\n    const variables = this.collectVariables(goals);\n    const shown = variables.filter((v) => subst.has(v));\n    if (shown.length === 0) {\n      return;\n    }\n    this.outputHandler('Bindings:');\n    for (const name of shown) {\n      const value = subst.get(name)!;\n      this.outputHandler(`  ${name} = ${this.termToString(value, subst)}`);\n    }\n  }\n\n  private collectVariables(goals: AST.Condition[]): string[] {\n    const names = new Set<string>();\n    const visitTerm = (term: AST.Term) => {\n      switch (term.type) {\n        case 'Variable':\n          if (!term.anonymous) names.add(term.name);\n          break;\n        case 'List':\n          term.elements.forEach(visitTerm);\n          if (term.tail) visitTerm(term.tail);\n          break;\n        case 'CompoundTerm':\n          term.args.forEach(visitTerm);\n          break;\n        case 'FieldAccess':\n          break;\n      }\n    };\n\n    const visitCondition = (cond: AST.Condition) => {\n      switch (cond.type) {\n        case 'PredicateCall':\n          cond.arguments.forEach(visitTerm);\n          break;\n        case 'SemanticMatch':\n          visitTerm(cond.left);\n          visitTerm(cond.right);\n          break;\n        case 'Equality':\n          visitTerm(cond.left);\n          visitTerm(cond.right);\n          break;\n        case 'Negation':\n          cond.goals.forEach(visitCondition);\n          break;\n        case 'Disjunction':\n          cond.left.forEach(visitCondition);\n          cond.right.forEach(visitCondition);\n          break;\n        case 'IfThenElse':\n          cond.condition.forEach(visitCondition);\n          cond.thenBranch.forEach(visitCondition);\n          cond.elseBranch.forEach(visitCondition);\n          break;\n        case 'Cut':\n          break;\n      }\n    };\n\n    goals.forEach(visitCondition);\n    return Array.from(names);\n  }\n\n  private getFieldValue(objectName: string, fieldName: string): string | string[] | null {\n    const concept = this.kb.concepts.get(objectName);\n    if (concept) {\n      if (fieldName === 'description' && concept.description) return concept.description;\n      if (fieldName === 'genus' && concept.genus) return concept.genus;\n      if (fieldName === 'attributes') return concept.attributes;\n      if (fieldName === 'essentials') return concept.essentials;\n    }\n\n    const entity = this.kb.entities.get(objectName);\n    if (entity) {\n      if (fieldName === 'description' && entity.description) return entity.description;\n      if (fieldName === 'concept' || fieldName === 'conceptType') return entity.conceptType;\n      // Check custom properties\n      if (entity.properties && entity.properties.has(fieldName)) {\n        return entity.properties.get(fieldName)!;\n      }\n      const entityConcept = this.kb.concepts.get(entity.conceptType);\n      if (entityConcept) {\n        if (fieldName === 'attributes') return entityConcept.attributes;\n        if (fieldName === 'essentials') return entityConcept.essentials;\n        if (fieldName === 'genus' && entityConcept.genus) return entityConcept.genus;\n      }\n    }\n\n    return null;\n  }\n\n  private hasCut(subst: Substitution): boolean {\n    return subst.has(CUT_MARKER);\n  }\n\n  private markCut(subst: Substitution): Substitution {\n    const next = new Map(subst);\n    next.set(CUT_MARKER, { type: 'Atom', value: '!' } as AST.Atom);\n    return next;\n  }\n\n  getMatcher(): SemanticMatcherWeb {\n    return this.matcher;\n  }\n}\n", "// Browser LLM-as-Judge Semantic Matcher\n// Uses structured output from localhost:9090 to measure attribute similarity\n\nconst SYSTEM_PROMPT = `You are measuring attribute similarity for concept formation.\n\nGiven an axis (a measurable attribute) and two concretes, determine how similar they are along ONLY that axis, ignoring all other properties.\n\nThis follows measurement-omission: concepts group concretes that share an attribute while differing in its measurement. You are measuring whether two concretes HAVE the attribute and how comparable their measurements are.\n\nScoring:\n- 1.0: Same or nearly identical measurement on this axis\n- 0.7-0.9: Clearly comparable, same general range\n- 0.4-0.6: Both possess the attribute but measurements differ significantly\n- 0.1-0.3: One possesses the attribute weakly or metaphorically\n- 0.0: One or both lack this attribute entirely\n\nRespond with ONLY a decimal number between 0 and 1.`;\n\nexport type ProgressCallback = (progress: { status: string; progress?: number }) => void;\n\ninterface SimilarityResponse {\n  similarity: number;\n}\n\nexport class SemanticMatcherWeb {\n  private readonly threshold: number;\n  private readonly endpoint: string;\n\n  constructor(threshold: number = 0.7, endpoint: string = 'http://localhost:9090') {\n    this.threshold = threshold;\n    this.endpoint = endpoint;\n  }\n\n  async initialize(onProgress?: ProgressCallback): Promise<void> {\n    // No initialization needed for LLM-as-judge approach\n    if (onProgress) {\n      onProgress({ status: 'ready', progress: 100 });\n    }\n  }\n\n  private async getSimilarityScore(axis: string, concrete1: string, concrete2: string): Promise<number> {\n    const userMessage = `Axis: ${axis}\\nConcrete 1: ${concrete1}\\nConcrete 2: ${concrete2}`;\n\n    try {\n      const response = await fetch(`${this.endpoint}/v1/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            { role: 'system', content: SYSTEM_PROMPT },\n            { role: 'user', content: userMessage }\n          ],\n          response_format: {\n            type: 'json_schema',\n            json_schema: {\n              name: 'similarity_score',\n              strict: true,\n              schema: {\n                type: 'object',\n                properties: {\n                  similarity: { type: 'number' }\n                },\n                required: ['similarity'],\n                additionalProperties: false\n              }\n            }\n          }\n        })\n      });\n\n      if (!response.ok) {\n        console.error(`LLM judge request failed: ${response.status} ${response.statusText}`);\n        return 0;\n      }\n\n      const data = await response.json() as { choices?: Array<{ message?: { content?: string } }> };\n      const content = data.choices?.[0]?.message?.content;\n\n      if (!content) {\n        console.error('No content in LLM response');\n        return 0;\n      }\n\n      const parsed: SimilarityResponse = JSON.parse(content);\n      const similarity = Math.max(0, Math.min(1, parsed.similarity));\n      console.log(`LLM judge similarity for \"${axis}\" between \"${concrete1}\" and \"${concrete2}\": ${similarity.toFixed(4)}`);\n      return similarity;\n    } catch (error) {\n      console.error('Error calling LLM judge:', error);\n      return 0;\n    }\n  }\n\n  async match(left: string | string[], right: string): Promise<boolean> {\n    // For =~= operator: asks whether descriptions pick out the same concept/referent\n    const axis = 'conceptual identity';\n\n    if (typeof left === 'string') {\n      const similarity = await this.getSimilarityScore(axis, left, right);\n      console.log(`Similarity between \"${left}\" and \"${right}\": ${similarity.toFixed(4)}`);\n      return similarity >= this.threshold;\n    } else {\n      for (const item of left) {\n        const similarity = await this.getSimilarityScore(axis, item, right);\n        console.log(`Similarity between \"${item}\" and \"${right}\": ${similarity.toFixed(4)}`);\n        if (similarity >= this.threshold) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  async getSimilarity(left: string, right: string): Promise<number> {\n    const similarity = await this.getSimilarityScore('conceptual identity', left, right);\n    console.log(`Similarity between \"${left}\" and \"${right}\": ${similarity.toFixed(4)}`);\n    return similarity;\n  }\n\n  async matchWithThreshold(left: string | string[], right: string, dim?: string): Promise<boolean> {\n    const axis = dim || 'conceptual identity';\n\n    if (typeof left === 'string') {\n      const similarity = await this.getSimilarityScore(axis, left, right);\n      console.log(`Similarity for \"${axis}\" between \"${left}\" and \"${right}\": ${similarity.toFixed(4)}`);\n      return similarity >= this.threshold;\n    } else {\n      for (const item of left) {\n        const similarity = await this.getSimilarityScore(axis, item, right);\n        console.log(`Similarity for \"${axis}\" between \"${item}\" and \"${right}\": ${similarity.toFixed(4)}`);\n        if (similarity >= this.threshold) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n}\n", "// Frisco Web REPL - Browser Entry Point\nimport { Lexer } from '../../src/lexer';\nimport { Parser } from '../../src/parser';\nimport { ExecutorWeb } from './executor-web';\nimport { SemanticMatcherWeb } from './semantic-matcher-web';\n\n// Global state\nlet executor: ExecutorWeb | null = null;\nlet matcher: SemanticMatcherWeb | null = null;\nlet isReady = false;\n\n// DOM elements\nconst outputEl = document.getElementById('output') as HTMLDivElement;\nconst inputEl = document.getElementById('input') as HTMLInputElement;\nconst runBtn = document.getElementById('run') as HTMLButtonElement;\nconst statusEl = document.getElementById('status') as HTMLDivElement;\nconst progressEl = document.getElementById('model-progress') as HTMLDivElement;\nconst progressTextEl = document.getElementById('progress-text') as HTMLSpanElement;\nconst progressFillEl = document.getElementById('progress-fill') as HTMLDivElement;\n\n// Split source into statements by '.', respecting strings\nfunction splitStatements(source: string): string[] {\n  const statements: string[] = [];\n  let current = '';\n  let inString = false;\n\n  for (let i = 0; i < source.length; i++) {\n    const char = source[i];\n\n    if (char === '\"' && (i === 0 || source[i - 1] !== '\\\\')) {\n      inString = !inString;\n      current += char;\n    } else if (char === '.' && !inString && (i + 1 >= source.length || source[i + 1] === ' ' || source[i + 1] === '\\n' || source[i + 1] === '\\t')) {\n      if (current.trim()) {\n        statements.push(current.trim());\n      }\n      current = '';\n      // Skip the '.' character\n    } else {\n      current += char;\n    }\n  }\n\n  // Don't forget trailing content without a dot\n  if (current.trim()) {\n    statements.push(current.trim());\n  }\n\n  return statements;\n}\n\nfunction appendOutput(text: string, className: string = '') {\n  const line = document.createElement('div');\n  line.className = `output-line ${className}`;\n  line.textContent = text;\n  outputEl.appendChild(line);\n  outputEl.scrollTop = outputEl.scrollHeight;\n}\n\nfunction clearOutput() {\n  outputEl.innerHTML = '';\n}\n\nasync function initializeMatcher() {\n  matcher = new SemanticMatcherWeb(0.7);\n  progressEl.classList.add('visible');\n\n  await matcher.initialize((progress) => {\n    if (progress.status === 'progress' && progress.progress !== undefined) {\n      const percent = Math.round(progress.progress);\n      progressFillEl.style.width = `${percent}%`;\n       progressTextEl.textContent = `Downloading BGE-M3 model... ${percent}%`;\n     } else if (progress.status === 'done') {\n       progressTextEl.textContent = 'BGE-M3 model loaded!';\n    } else if (progress.status === 'ready') {\n      progressEl.classList.remove('visible');\n    }\n  });\n\n  progressEl.classList.remove('visible');\n}\n\nasync function initialize() {\n  try {\n     appendOutput('Initializing BGE-M3 embedding model (first load may take a moment)...', 'info');\n    await initializeMatcher();\n\n    executor = new ExecutorWeb(\n      0.7,\n      matcher!,\n      (msg) => appendOutput(msg, 'result'),\n      async (prompt) => {\n        return new Promise((resolve) => {\n          const result = window.prompt(prompt || 'Enter input:');\n          resolve(result || '');\n        });\n      }\n    );\n\n    isReady = true;\n    statusEl.textContent = 'Ready';\n    statusEl.className = 'ready';\n    inputEl.disabled = false;\n    runBtn.disabled = false;\n    appendOutput('Ready! Enter Frisco code below.', 'info');\n  } catch (error) {\n    statusEl.textContent = 'Error';\n    statusEl.className = 'error';\n    appendOutput(`Failed to initialize: ${error}`, 'error');\n  }\n}\n\nasync function runCode(source: string) {\n  if (!isReady || !executor) {\n    appendOutput('Not ready yet. Please wait for initialization.', 'error');\n    return;\n  }\n\n  // Auto-convert bare expressions to queries\n  // Split by '.' and process each statement\n  let processedSource = source.trim();\n\n  // Split into statements (handling strings that may contain dots)\n  const statements = splitStatements(processedSource);\n  const processedStatements = statements.map(stmt => {\n    stmt = stmt.trim();\n    if (!stmt) return '';\n\n    const isDeclaration =\n      stmt.startsWith('?') ||\n      stmt.startsWith('concept ') ||\n      stmt.startsWith('entity ') ||\n      stmt.includes(':-');\n\n    const looksLikeQuery =\n      /^[a-z_][a-zA-Z0-9_]*\\s*\\(/.test(stmt) ||  // predicate call\n      stmt.includes('=~=') ||                      // semantic match\n      /^\".*\"/.test(stmt) ||                        // starts with string\n      /^\\[/.test(stmt);                            // starts with list\n\n    if (!isDeclaration && looksLikeQuery) {\n      return '? ' + stmt + '.';\n    }\n    return stmt + '.';\n  });\n\n  processedSource = processedStatements.filter(s => s).join(' ');\n\n  appendOutput(source, 'input');\n\n   try {\n     const lexer = new Lexer(processedSource);\n     const tokens = lexer.tokenize();\n     const parser = new Parser(tokens);\n     const ast = parser.parse();\n     await executor.execute(ast);\n  } catch (error) {\n    if (error instanceof Error) {\n      appendOutput(`Error: ${error.message}`, 'error');\n    } else {\n      appendOutput(`Error: ${error}`, 'error');\n    }\n  }\n}\n\n// Event handlers\nrunBtn.addEventListener('click', () => {\n  const code = inputEl.value.trim();\n  if (code) {\n    runCode(code);\n    inputEl.value = '';\n  }\n});\n\ninputEl.addEventListener('keydown', (e) => {\n  if (e.key === 'Enter') {\n    const code = inputEl.value.trim();\n    if (code) {\n      runCode(code);\n      inputEl.value = '';\n    }\n  }\n});\n\n// Example buttons\ndocument.querySelectorAll('.example-btn').forEach((btn) => {\n  btn.addEventListener('click', () => {\n    const code = btn.getAttribute('data-code');\n    if (code) {\n      inputEl.value = code;\n      inputEl.focus();\n    }\n  });\n});\n\n// Start initialization\ninitialize();\n"],
  "mappings": "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",
  "names": ["matcher"]
}
